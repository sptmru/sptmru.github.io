<!DOCTYPE html> <html lang="ru"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content="352510442"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Как работает HTTP: разбор в деталях | Всякое о JS на бэкенде</title> <meta name="author" content="Сослан Х. Алдатов"> <meta name="description" content="Статья об HTTP, HTTP/2, HTTPS и вот этом всем"> <meta name="keywords" content="sptm, sptmru, Soslan Aldatov, Node.js, JavaScript, backend, mentor, mentoring"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700%7CRoboto+Slab:100,300,400,500,700%7CMaterial+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://sptmru.github.io/2023/http-in-details/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">главная</a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">репозитории</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">менторинг</a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">блог <span class="sr-only">(current)</span> </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Как работает HTTP: разбор в деталях</h1> <p class="post-meta">February 6, 2023</p> <p class="post-tags"> <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/blog/tag/theory"> <i class="fas fa-hashtag fa-sm"></i> theory</a>     ·   <a href="/blog/category/theory"> <i class="fas fa-tag fa-sm"></i> theory</a>   </p> </header> <article class="post-content"> <h2 id="введение">Введение</h2> <p>Частый вопрос на собеседованиях у бэкенд-разработчиков (и, действительно, это важно знать): что такое HTTP и как он работает?</p> <p>Вот об этом мы сегодня и поговорим. Постараемся нырнуть достаточно глубоко, заодно задеть HTTPS и в целом сконцентрировать в этой статье все знания об HTTP, которые нужны любому бэкенд-разработчику.</p> <h2 id="что-такое-http">Что такое HTTP?</h2> <p>HTTP (HyperText Transfer Protocol, протокол передачи гипертекста) — это, как понятно из названия, протокол, то есть некая договоренность о том, как сервер и клиент взаимодействуют в контексте передачи гипертекста (это странное слово значит всего лишь текст с гиперссылками). Сейчас, впрочем, по HTTP передают далеко не только текст со ссылками (но и его тоже).</p> <p>Работает HTTP на прикладном уровне, и работает он поверх TCP (который, в свою очередь, работает на транспортном уровне. Когда-нибудь я напишу статью об уровнях модели OSI, но пока она даже не в бэклоге). По умолчанию HTTP использует порт 80/tcp, но может работать и на любом другом порту — все зависит от настроек сервера.</p> <p>Используем мы его очень часто, так как это основной протокол, по которому работает WWW. Когда ваш браузер открывает сайт, он делает это по HTTP (точнее, сначала по DNS, потом по HTTP, а потом (крайне вероятно) по HTTPS (который самостоятельным протоколом не является, это расширение протокола HTTP, и мы его в этой статье тоже затронем)).</p> <p>HTTP работает в рамках клиент-серверной архитектуры, то есть выглядит это примерно так:</p> <ul> <li>клиент (часто браузер) запрашивает у сервера некий ресурс</li> <li>сервер обрабатывает запрос и возвращает клиенту что-то (и это не всегда то, что просил клиент): возможно, это тот самый ресурс, может быть, что это указание, где этот ресурс на самом деле лежит, а может быть, и ошибка.</li> </ul> <p>Давайте чуть подробнее разберем обмен сообщениями между клиентом и сервером.</p> <h2 id="http-запросы-и-http-ответы">HTTP-запросы и HTTP-ответы</h2> <p>HTTP-сообщения бывают двух видов: это, как мы уже поняли, запросы и ответы. Клиент отправляет запрос — а сервер на него отвечает (всегда, если не рассматривать ситуации с проблемами с сетевым соединением, доступностью сервера и типа того).</p> <p>Как запросы, так и ответы выглядят примерно так:</p> <ol> <li>Стартовая строка — в ней содержится версия HTTP, которую мы используем, и другая информация — типа запрашиваемого ресурса или кода ответа.</li> <li>Заголовки HTTP (далее мы поговорим о них подробнее): несколько строчек текста в заранее оговоренном формате, которые как-то уточняют запрос или содержимое ответа.</li> <li>Пустая строка, которая означает, что все метаданные (версия протокола, заголовки — в общем, все, что было в первых двух пунктах) отправлены.</li> <li>Тело сообщения (которое существует не всегда) — к примеру, данные, связанные с запросом, или HTML-страница, переданная в ответе.</li> </ol> <p>Давайте смотреть на все пункты подробнее.</p> <h3 id="http-запрос">HTTP-запрос</h3> <h4 id="стартовая-строка-http-запроса">Стартовая строка HTTP-запроса</h4> <p>Стартовая строка HTTP-запроса выглядит как-то так:</p> <p><code class="language-plaintext highlighter-rouge">GET /index.html HTTP/1.1</code></p> <p>Первая часть (<code class="language-plaintext highlighter-rouge">GET</code>) — это метод запроса. Он говорит серверу, что мы вообще от него хотим. Вот список самых популярных HTTP-методов:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">GET</code> — запрашивает какой-то ресурс у сервера (в примере <code class="language-plaintext highlighter-rouge">/index.html</code>)</li> <li> <code class="language-plaintext highlighter-rouge">HEAD</code> — это как <code class="language-plaintext highlighter-rouge">GET</code>, только сервер вернет исключительно заголовки, не сам ресурс. Используется, к примеру, для того, чтобы узнать размер ресурса перед его загрузкой</li> <li> <code class="language-plaintext highlighter-rouge">POST</code> — позволяет отправить данные на сервер. Используется для создания чего-то, часто - для авторизации / аутентификации, загрузки данных на сервер (типа изображений или документов)</li> <li> <code class="language-plaintext highlighter-rouge">PUT</code> / <code class="language-plaintext highlighter-rouge">PATCH</code> — позволяет изменить что-то, уже существующее на сервере</li> <li> <code class="language-plaintext highlighter-rouge">DELETE</code> — что-то удаляет на сервере</li> <li> <code class="language-plaintext highlighter-rouge">OPTIONS</code> — спрашивает информацию о сервере, в том числе список поддерживаемых сервером методов</li> </ul> <p>Вторая часть <code class="language-plaintext highlighter-rouge">/index.html</code> — это URI (Uniform Resource Identifier, унифицированный идентификатор ресурса) — это путь к ресурсу, который мы хотим загрузить / поменять / создать (в зависимости от метода и конфигурации сервера).</p> <p>Третья часть — версия HTTP, в соответствии с которой составлен запрос. В примере — 1.1. Вообще, сейчас гораздо более популярна версия <code class="language-plaintext highlighter-rouge">HTTP/2</code>, но сайты с <code class="language-plaintext highlighter-rouge">HTTP/1.1</code> вполне себе встречаются.</p> <h4 id="заголовки-http-запроса">Заголовки HTTP-запроса</h4> <p>Заголовки запроса этот самый запрос уточняют. Давайте перечислим самые популярные из них:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">Host</code> — единственный обязательный заголовок запроса. Содержит доменное имя или IP-адрес, к которому мы обращаемся. Для чего это нужно? В том числе для того, чтобы сервер понимал, к какому именно доменному имени / IP-адресу мы обращаемся — ведь на сервере может быть размещено несколько сайтов на разных IP-адресах или доменных именах (это называется “IP-Based Virtual Host” / “Name-Based Virtual Host”).</li> <li> <code class="language-plaintext highlighter-rouge">User-Agent</code> — описывает клиент, который обращается к серверу.</li> <li> <code class="language-plaintext highlighter-rouge">Refer</code> — содержит информацию о том, откуда поступил текущий запрос (к примеру, вы переходите с сайта <code class="language-plaintext highlighter-rouge">http://site1.com</code> по ссылке на сайт <code class="language-plaintext highlighter-rouge">http://site2.com</code> — тогда в заголовке <code class="language-plaintext highlighter-rouge">Refer</code>, вероятно, будет содержаться <code class="language-plaintext highlighter-rouge">http://site1.com</code>).</li> <li> <code class="language-plaintext highlighter-rouge">Accept</code> — указывает, какие типы медиафайлов умеет принимать клиент.</li> <li> <code class="language-plaintext highlighter-rouge">Cookie</code> — может содержать куки, предварительно отправленные на сервер или отправленные сервером (с помощью заголовка ответа <code class="language-plaintext highlighter-rouge">Set-Cookie</code>, который мы разберем позже).</li> <li> <code class="language-plaintext highlighter-rouge">Authorization</code> — обычно работает так: после какого-то рода аутентификации клиента на сервере сервер возвращает некий токен, который клиент после отправляет в каждом запросе. Вот как раз в заголовке <code class="language-plaintext highlighter-rouge">Authorization</code> этот токен и отправляется.</li> </ul> <p>А вот <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers" rel="external nofollow noopener" target="_blank">здесь</a> можно почитать о других HTTP-заголовках.</p> <h4 id="тело-сообщения-http-запроса">Тело сообщения HTTP-запроса</h4> <p>HTTP-запрос завершается телом. Но далеко не у каждого запроса предполагается наличие тела: тело есть у запросов, что-то меняющих на сервере — то есть у запросов с методами <code class="language-plaintext highlighter-rouge">GET</code>, <code class="language-plaintext highlighter-rouge">HEAD</code>, <code class="language-plaintext highlighter-rouge">OPTIONS</code> наличие тела не предполагается (хотя никто не запрещает его передавать), а у запросов с методами <code class="language-plaintext highlighter-rouge">POST</code>, <code class="language-plaintext highlighter-rouge">PUT</code>, <code class="language-plaintext highlighter-rouge">PATCH</code> наличие тела предполагается (хотя его может не быть). Запросы <code class="language-plaintext highlighter-rouge">DELETE</code> обычно не имеют тела, потому что, хоть и что-то меняют на сервере, но не добавляют никаких новых данных. Но, опять же, и у таких запросов может быть тело.</p> <h3 id="http-ответ">HTTP-ответ</h3> <p>Как мы определили ранее, если с сетью и сервером все в порядке, каждый HTTP-запрос получит ответ. Давайте разберемся, из чего обычно состоят HTTP-ответы.</p> <h4 id="стартовая-строка-строка-статуса-http-ответа">Стартовая строка (строка статуса) HTTP-ответа</h4> <p>Стартовая строка (которую еще называют строкой статуса) HTTP-ответа может выглядеть, к примеру, так:</p> <p><code class="language-plaintext highlighter-rouge">HTTP 1/1 200 OK</code></p> <p>Здесь первая часть (<code class="language-plaintext highlighter-rouge">HTTP 1/1</code>) — это знакомая нам по стартовой строке HTTP-запроса версия HTTP-протокола. Вторая часть (<code class="language-plaintext highlighter-rouge">200</code> в примере) — это код состояния, а третья (<code class="language-plaintext highlighter-rouge">OK</code>) — его текстовое описание. Коды состояния мы разберем подробнее. Итак, коды состояния бывают такие:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">1xx</code> — коды, начинающиеся с единицы, никак не влияют на обработку запроса и просто передают информацию. Например, код <code class="language-plaintext highlighter-rouge">101 Switching Protocols</code> сообщает клиенту о смене протокола. Вот такой вот ответ говорит клиенту, что сервер переходит с HTTP на WebSockets:</li> </ul> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">101</span> <span class="ne">Switching Protocols</span>
<span class="na">Upgrade</span><span class="p">:</span> <span class="s">websocket</span>
<span class="na">Connection</span><span class="p">:</span> <span class="s">Upgrade</span>
</code></pre></div></div> <ul> <li> <p><code class="language-plaintext highlighter-rouge">2xx</code> — коды, начинающиеся с двойки, возвращаются тогда, когда клиентский запрос был успешно обработан. Например, код <code class="language-plaintext highlighter-rouge">200 OK</code> вернется вместе с запрошенным ресурсом, а <code class="language-plaintext highlighter-rouge">201 Created</code> вернется, когда что-то успешно создано на сервере.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">3xx</code> — коды, начинающиеся с тройки, возвращаются, когда серверу нужно куда-то перенаправить клиента. Например, код <code class="language-plaintext highlighter-rouge">301 Moved Permanently</code> означает, что запрошенный ресурс теперь доступен по новому URI (который передается в заголовке <code class="language-plaintext highlighter-rouge">Location</code>).</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">4xx</code> — коды, которые начинаются с четверки, означают, что клиент отправил некорректный запрос. Например, код <code class="language-plaintext highlighter-rouge">403 Forbidden</code> означает, что у клиента нет доступа к запрошенному ресурсу, а всем известный <code class="language-plaintext highlighter-rouge">404 Not Found</code> означает, что запрошенный ресурс не найден.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">5xx</code> — коды, начинающиеся с пятерки, означают ошибку на сервере. К примеру, код <code class="language-plaintext highlighter-rouge">504 Gateway Timeout</code> говорит клиенту о том, что сервер, выполняя роль прокси, не дождался ответа от апстрима вовремя.</p> </li> </ul> <p>О всех возможных кодах состояния можно почитать <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status" rel="external nofollow noopener" target="_blank">здесь</a>.</p> <h4 id="заголовки-http-ответа">Заголовки HTTP-ответа</h4> <p>Заголовки ответа используются для того, чтобы этот самый ответ уточнить, и не влияют на тело ответа. Заголовки HTTP-ответа выглядят абсолютно так же, как заголовки запроса.</p> <p>Вот примеры часто встречающихся заголовков ответа:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">Server</code> — содержит информацию о сервере. Пример: <code class="language-plaintext highlighter-rouge">Server: nginx</code>.</li> <li> <code class="language-plaintext highlighter-rouge">Set-Cookie</code> — мы уже упоминали этот заголовок ранее. Он устанавливает куки, которые клиент затем сохраняет у себя. Пример: <code class="language-plaintext highlighter-rouge">Set-Cookie:PHPSSID=bf42938f</code>.</li> <li> <code class="language-plaintext highlighter-rouge">WWW-Authenticate</code> — говорит клиенту, какой тип аутентификации используется для доступа к запрашиваемому ресурсу. Например: <code class="language-plaintext highlighter-rouge">WWW-Authenticate: BASIC realm=»localhost»</code>.</li> </ul> <h4 id="тело-ответа">Тело ответа</h4> <p>Обычно тело ответа присутствует, но иногда вся необходимая информация содержится в заголовке (типа <code class="language-plaintext highlighter-rouge">201 Created</code> или <code class="language-plaintext highlighter-rouge">204 No Content</code>), и тела у ответа тогда нет.</p> <h2 id="http2">HTTP/2</h2> <p>Для того, чтобы ответить на вопрос, зачем создавался HTTP/2 и в чем его основное преимущество, мы начнем с протокола <code class="language-plaintext highlighter-rouge">SPDY</code>, разработанного в Google как замена некоторых частей HTTP — в частности, по задумке разработчиков, вместо отдельного соединения для каждого ресурса используется мультиплексирование — таким образом, для передачи нескольких файлов теперь требовалось только одно соединение, что значительно ускоряло работу сайта. В 2011-2012 годов этот протокол поддерживался большинством браузеров и активно использовался в вебе.</p> <p>В 2015 году Рабочая группа HTTP IETF (Инженерного Совета Интернета) пересмотрела протокол HTTP и разработала версию протокола HTTP/2, которая в том числе включала мультиплексирование. В мае того же года протокол HTTP/2 был официально стандартизирован.</p> <h3 id="особенности-http2">Особенности HTTP/2</h3> <ul> <li>мультиплексированные потоки</li> </ul> <p>В отличие от модели “запрос-ответ”, используемой в HTTP/1.1, в HTTP/2 используются мультиплексированные потоки — данные в обе стороны передаются в рамках одного TCP-соединения в бинарном формате. Такой подход дает кучу преимуществ:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    - параллельные мультиплексированные запросы и ответы не блокируют друг друга
    - несмотря на передачу кучи данных, для наибольшей эффективности работы сети используется одно TCP-соединение
    - сервер может отправлять данные по своей инициативе (Server Push)
    - клиент может приоритезировать потоки, отдавая предпочтение конкретным потокам данных
    - заголовки сжимаются с помощью алгоритма HPACK
</code></pre></div></div> <p>Таким образом, HTTP/2 ощутимо быстрее HTTP/1.1. И да, на текущий момент гораздо популярнее. Кстати, переходя к следующей главе: HTTP/2 требует использования HTTPS.</p> <h2 id="https">HTTPS</h2> <p>HTTP имеет один фатальный недостаток: все данные передаются в открытом виде, что означает, что все данные, которыми клиент и сервер обмениваются друг с другом, можно перехватить. Это делает практически невозможным работу сервисов, которые обмениваются какими-то важными данными — типа банковских приложений, интернет-магазинов, каких-то государственных сервисов — в общем, всех сервисов, перехват данных для которых несет негативные последствия.</p> <p>Поэтому еще в 1994 году было разработано расширение протокола HTTP — HTTP Secure, или HTTPS. HTTPS, в отличие от HTTP, использует порт 443/tcp по умолчанию. До 2015 года он использовал протокол шифрования SSL, теперь же он использует TLS, но суть не поменялась.</p> <p>HTTPS работает благодаря TLS/SSL-сертификату. Этот сертификат можно назвать некой цифровой подписью сайта, с его помощью подтверждается подлинность сайта. Перед тем, как установить защищенное соединение, клиент запрашивает этот сертификат и обращается к центру сертификации, который этот сертификат выпустил, чтобы подтвердить легальность сертификата. Если сертификат действителен, клиент считает сайт безопасным и начинает обмен данными.</p> <p>Кроме подтверждения подлинности сайта, сертификат шифрует данные. После определения подлинности сайта начинается обмен шифрами. Шифрование HTTPS происходит с помощью асимметричного и симметричного ключа. Давайте рассмотрим их подробнее.</p> <h3 id="асимметричный-ключ">Асимметричный ключ</h3> <p>Каждая сторона имеет два ключа: публичный и приватный. Публичный ключ доступен любому, приватный — только владельцу. Когда клиент хочет отправить сообщение, он находит публичный ключ сервера, шифрует им сообщение, создавая секретный ключ, и отправляет серверу. Сервер расшифровывает полученное сообщение своим приватным ключом и делает то же самое: достает публичный ключ клиента, шифрует им сообщение, отправляет клиенту, клиент расшифровывает его своим приватным ключом. Теперь у каждой из сторон есть одинаковый секретный ключ.</p> <h3 id="симметричный-ключ">Симметричный ключ</h3> <p>Когда клиент и сервер установили первичное соединение и создали секретный ключ, они используют его для шифрования всех данных, которые передают друг другу. Так как ключ не надо создавать заново каждый раз, симметричный ключ быстрее.</p> <h2 id="в-завершение">В завершение</h2> <p>Вот <a href="https://developer.mozilla.org/en-US/docs/" rel="external nofollow noopener" target="_blank">здесь</a> есть вся документация по HTTP. По сравнению с ней, эта статья — просто ознакомительная :)</p> <p>Завершить хотелось бы тем, что HTTP и сам используется как транспорт — для таких протоколов, как SOAP, XML-RPC, WebDAV. REST, опять же, использует HTTP как транспорт. Мы можем считать HTTP как минимум одним из главных протоколов интернета.</p> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2023 Сослан Х. Алдатов. Лежит на <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Бронируйте встречи на <a href="https://sptm.dev/meetme" target="_blank" rel="external nofollow noopener">моем Fantastical Openings</a>. Фото стянуты в том числе из <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-P58WVSR9JS"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-P58WVSR9JS");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>