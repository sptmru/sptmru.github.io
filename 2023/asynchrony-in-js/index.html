<!DOCTYPE html> <html lang="ru"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content="352510442"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Асинхронность в JavaScript: практика и теория | Всякое о JS на бэкенде</title> <meta name="author" content="Сослан Х. Алдатов"> <meta name="description" content="Меня зовут Сослан, и это мой личный сайт. Вообще, он создан, чтоб постить сюда всякое о Node.js и бэкенде в целом. "> <meta name="keywords" content="sptm, sptmru, Soslan Aldatov, Node.js, JavaScript, backend, mentor, mentoring"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700%7CRoboto+Slab:100,300,400,500,700%7CMaterial+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://sptmru.github.io/2023/asynchrony-in-js/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">главная</a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">репозитории</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">менторинг</a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">блог <span class="sr-only">(current)</span> </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Асинхронность в JavaScript: практика и теория</h1> <p class="post-meta">February 3, 2023</p> <p class="post-tags"> <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/blog/tag/js"> <i class="fas fa-hashtag fa-sm"></i> js</a>     ·   <a href="/blog/category/javascript"> <i class="fas fa-tag fa-sm"></i> javascript</a>   </p> </header> <article class="post-content"> <p>Достаточно важная как для браузерного JS, так и для Node.js (на котором мы остановимся подробнее) тема — асинхронность. Все мы слышали и знаем, что JavaScript — язык асинхронный, и все мы знаем, что он еще и однопоточный.</p> <p>Если чуть задуматься об этом, становится непонятно: а как такое в принципе возможно? Если у нас есть только один поток, то что произойдет, если мы выполним в нем блокирующую операцию — например, обратимся к файловой системе или базе данных? Разве может успешно существовать язык программирования, с программами на котором может одновременно работать только один процесс?</p> <p>Конечно, в JS это решено, и решено довольно интересно. И, как и все интересные штуки, эта штука достаточно сложна. Поэтому эта статья — статья-перевертыш: мы начнем с того, как на практике работать с асинхронными задачами, а уже потом разберем, что там под капотом происходит.</p> <h2 id="практика">Практика</h2> <h3 id="callbacks">Callbacks</h3> <p>Итак, для начала вернемся во времена до выхода ES6, существенно прокачавшего JS. Тогда, в эти прекрасные дни, асинхронные штуки мы делали примерно так:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">blockingFunc</span> <span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// do blocking things</span>
  <span class="nx">callback</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">logDone</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Done</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">blockingFunc</span><span class="p">(</span><span class="nx">logDone</span><span class="p">);</span>
</code></pre></div></div> <p>Что здесь происходит? У нас есть некая функция <code class="language-plaintext highlighter-rouge">blockingFunc()</code>, которая делает нечто, блокирующее наш поток, а потом выполняет некую функцию <code class="language-plaintext highlighter-rouge">callback()</code>, которую она принимает аргументом (да, в JavaScript мы можем передать в функцию аргументом другую функцию. Это называется «функции первого класса». На самом деле, мы можем даже передать в функцию целый класс, и получится у нас класс первого класса. Но это уже другая тема).</p> <p>В чем проблема такого подхода к написанию кода? А в том, что называли «callback hell». Мы выполняем функцию, в которую передаем функцию-коллбек, в которую передавали свою функцию-коллбек…и очень скоро это превращалось во что-то не очень читаемое. Смотрите:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">getBeef</span><span class="p">(</span><span class="dl">'</span><span class="s1">John</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">rawBeef</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">sliceBeef</span><span class="p">(</span><span class="nx">rawBeef</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">slicedBeef</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">cookBeef</span><span class="p">(</span><span class="nx">slicedBeef</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">cookedBeef</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">serveBeef</span><span class="p">(</span><span class="nx">cookedBeef</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">servedBeef</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">servedBeef</span><span class="p">)</span>
      <span class="p">})</span>
    <span class="p">})</span>
  <span class="p">})</span>
<span class="p">})</span>
</code></pre></div></div> <p>Видите проблему такого подхода? Мне кажется даже, что здесь я запутался в коллбеках :) а читать такое попросту мучительно.</p> <h3 id="promises">Promises</h3> <p>К счастью, вместе с ES6 к нам пришли промисы (Promise) и async/await. Что это такое и как это использовать, рассмотрим ниже.</p> <p>Promise — это под капотом те же коллбеки, но использовать и читать их гораздо приятнее. Давайте перепишем код выше с использованием промисов. Представим, что функция <code class="language-plaintext highlighter-rouge">getBeef()</code> выглядит примерно так: (небольшое отступление: в ней я использовал еще одну фичу ES6 — стрелочные функции, о них можно прочитать у меня <a href="https://github.com/sptmlearningjs/execution-context-in-js" rel="external nofollow noopener" target="_blank">здесь</a>:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">getBeef</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">beefExists</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">beef</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="nx">resolve</span><span class="p">(</span><span class="nx">beef</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">reject</span><span class="p">(</span><span class="dl">'</span><span class="s1">No beef available</span><span class="dl">'</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">},</span> <span class="mi">300</span><span class="p">)</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div> <p>Что происходит здесь? Функция <code class="language-plaintext highlighter-rouge">getBeef(name)</code> принимает имя человека, для которого мы в итоге будем готовить мясо и возвращает объект Promise.</p> <p>Promise, как написано в документации, это такой прокси-объект для значения, которое не обязательно известно, когда промис создается. В нашем случае мы не знаем, есть ли у нас мясо, когда создаем промис, и для проверки нам нужно немного времени. Мы не хотим ждать, блокируя основной поток, поэтому проверяем это асинхронно.</p> <p>Promise находится в одном из трех состояний:</p> <ul> <li>pending: изначальное состояние созданного промиса</li> <li>fulfilled: означает, что операция выполнена успешно</li> <li>rejected: означает, что операция провалена</li> </ul> <p>Мы считаем промис выполненным (settled), если он либо выполнен успешно (fulfilled), либо провален (rejected), но не находится в ожидании (pending). Часто говорят, что промис зарезолвился (resolved), когда он выполнен.</p> <p>Когда мы создаем промис, мы устанавливаем значения, которые он вернет в случае, когда он выполнен успешно (с помощью функции <code class="language-plaintext highlighter-rouge">resolve()</code>) и когда он провален (с помощью <code class="language-plaintext highlighter-rouge">reject()</code>). В нашем случае, если промис выполнен успешно (условная переменная <code class="language-plaintext highlighter-rouge">beefExists === true</code>), мы вернем <code class="language-plaintext highlighter-rouge">beef</code> (то самое мясо), а если промис провален, мы вернем сообщение, что мяса, к сожалению, нет.</p> <p>У Promise есть три метода: <code class="language-plaintext highlighter-rouge">then()</code>, <code class="language-plaintext highlighter-rouge">catch()</code>, <code class="language-plaintext highlighter-rouge">finally()</code>. <code class="language-plaintext highlighter-rouge">then()</code> принимает два аргумента: первый — это коллбек, выполняющийся, когда промис успешно зарезолвился, второй — коллбек, который выполнится, если промис провалится. Често второй аргумент опускают, ведь есть <code class="language-plaintext highlighter-rouge">catch()</code>, который принимает один аргумент — коллбек, который выполнится, если промис провалится. <code class="language-plaintext highlighter-rouge">finally()</code> тоже принимает один аргумент, который выполнится, когда промис зарезолвится любым образом: провалится ли — или же успешно выполнится.</p> <p>Все эти методы возвращают новый Promise, что очень удобно, ведь их можно связывать в цепочки (chaining). Теперь давайте перепишем весь наш код на коллбеках с использованием промисов:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">getBeef</span><span class="p">(</span><span class="dl">'</span><span class="s1">John</span><span class="dl">'</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">sliceBeef</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">cookBeef</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">serveBeef</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">servedBeef</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">servedBeef</span> <span class="p">?</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Beef is served!</span><span class="dl">'</span><span class="p">):</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Beef is not served</span><span class="dl">'</span><span class="p">))</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">err</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">));</span>

</code></pre></div></div> <p>Гораздо более читабельно, правда?</p> <p>Есть еще два интересных метода, связанных с промисами: <code class="language-plaintext highlighter-rouge">Promise.all()</code> и <code class="language-plaintext highlighter-rouge">Promise.allSettled()</code>. Оба позволяют комбинировать промисы, получая из них новый, но <code class="language-plaintext highlighter-rouge">Promise.all()</code> будет считаться fulfilled только тогда, когда все переданные в него промисы будут fulfilled. Для <code class="language-plaintext highlighter-rouge">Promise.allSettled()</code> же, чтобы считаться fulfilled, достаточно, чтобы все промисы, в него переданные, не были pending (то есть все промисы должны как-то отрезолвиться, fulfilled или rejected — без разницы). Давайте посмотрим на примере:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">promise1</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span> <span class="c1">// fulfilled promise</span>
<span class="kd">const</span> <span class="nx">promise2</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span> <span class="c1">// also fulfilled promise</span>
<span class="kd">const</span> <span class="nx">promise3</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span> <span class="c1">// rejected promise</span>
<span class="kd">const</span> <span class="nx">promise4</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{});</span> <span class="c1">// pending promise</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">promise1</span><span class="p">,</span> <span class="nx">promise2</span><span class="p">])</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">fulfilled!</span><span class="dl">'</span><span class="p">))</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">rejected!</span><span class="dl">'</span><span class="p">));</span> <span class="c1">// fulfilled! (as all promises are fulfilled)</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">promise1</span><span class="p">,</span> <span class="nx">promise2</span><span class="p">,</span> <span class="nx">promise3</span><span class="p">])</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">fulfilled!</span><span class="dl">'</span><span class="p">))</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">rejected!</span><span class="dl">'</span><span class="p">));</span> <span class="c1">// rejected! (as promise3 is rejected)</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">promise1</span><span class="p">,</span> <span class="nx">promise2</span><span class="p">,</span> <span class="nx">promise4</span><span class="p">])</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">fulfilled!</span><span class="dl">'</span><span class="p">))</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">rejected!</span><span class="dl">'</span><span class="p">));</span> 
  <span class="c1">// nothing, Promise.all is still pending (for Promise.all to be resolved, all promises passed into it should be resolved)</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">allSettled</span><span class="p">([</span><span class="nx">promise1</span><span class="p">,</span> <span class="nx">promise2</span><span class="p">,</span> <span class="nx">promise3</span><span class="p">])</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">fulfilled!</span><span class="dl">'</span><span class="p">))</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">rejected!</span><span class="dl">'</span><span class="p">));</span> <span class="c1">// fulfilled! (as all promises are resolved)</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">allSettled</span><span class="p">([</span><span class="nx">promise1</span><span class="p">,</span> <span class="nx">promise2</span><span class="p">,</span> <span class="nx">promise4</span><span class="p">])</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">fulfilled!</span><span class="dl">'</span><span class="p">))</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">rejected!</span><span class="dl">'</span><span class="p">));</span> 
  <span class="c1">// nothing, Promise.allSettled is still pending (for Promise.allSettled to be resolved, all promises passed into it should be resolved)</span>
</code></pre></div></div> <p>Есть еще один прикольный метод, связанный с промисами — <code class="language-plaintext highlighter-rouge">Promise.race()</code>. Он похож на предыдущие два, разница лишь в том, что резолвится <code class="language-plaintext highlighter-rouge">Promise.race()</code> тогда, когда резолвится хотя бы один из переданных в него промисов. Глянем на примере:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">promise1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="dl">'</span><span class="s1">one</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>

<span class="kd">const</span> <span class="nx">promise2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="dl">'</span><span class="s1">two</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">race</span><span class="p">([</span><span class="nx">promise1</span><span class="p">,</span> <span class="nx">promise2</span><span class="p">]).</span><span class="nx">then</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
  <span class="c1">// Both resolve, but promise2 is faster</span>
<span class="p">});</span>
<span class="c1">// Expected output: "two"</span>
</code></pre></div></div> <h3 id="async--await">Async / Await</h3> <p>Итак, с промисами разобрались. Учитывая следующую тему, которую мы в этой статье разберем, стоит сказать: промисы — это не какая-то около-deprecated-штука, это вполне себе актуальная и часто используемая функциональность JS, и она никуда не пропадет. Почему я это говорю?</p> <p>А потому что в JS можно писать асинхронный код, который буквально выглядит как синхронный: для этого в ES6 вместе с промисами подъехал синтаксический сахар над ними — <code class="language-plaintext highlighter-rouge">async</code> и <code class="language-plaintext highlighter-rouge">await</code>. Давайте воспользуемся предыдущим опытом и перепишем код, что мы писали выше, с использованием <code class="language-plaintext highlighter-rouge">async/await</code>:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">beef</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">getBeef</span><span class="p">(</span><span class="dl">'</span><span class="s1">John</span><span class="dl">'</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">slicedBeef</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">sliceBeef</span><span class="p">(</span><span class="nx">beef</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">cookedBeef</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">cookBeef</span><span class="p">(</span><span class="nx">slicedBeef</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">servedBeef</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">serveBeef</span><span class="p">(</span><span class="nx">cookedBeef</span><span class="p">);</span>
    
    <span class="nx">servedBeef</span> <span class="p">?</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Beef is served!</span><span class="dl">'</span><span class="p">)</span> <span class="p">:</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Beef is not served!</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Стало еще более читабельно, правда? Но здесь нет ничего нового — это всего лишь синтаксический сахар (хотя, конечно, очень приятный) над промисами (которые, в свою очередь, просто синтаксический сахар над коллбеками. Но какая разница? Удобнее стало? Стало. Вот и отлично.)</p> <h2 id="теория">Теория</h2> <p>Что ж, с практикой мы вроде как разобрались. Пора закопаться поглубже и разобраться, как оно все работает. А работает оно довольно интересно.</p> <p>Давайте для начала разберемся, из чего состоит Node.js.</p> <h3 id="компоненты-nodejs">Компоненты Node.js</h3> <h4 id="v8">V8</h4> <p>Cобственно, движок, который компилирует и выполняет JavaScript-код, занимается выделением памяти под объекты и включает в себя сборщик мусора, который освобождает память, занимаемую объектом, когда ссылок на объект уже нет и он уже не нужен.</p> <p>Раньше V8 занимался JIT-компиляцией всегда, теперь же (с версии 7.4) у него появилась опция <code class="language-plaintext highlighter-rouge">—jitless</code>, в этом режиме он работает исключительно как интерпретатор. Это полезно, когда мы не можем аллоцировать память в рантайме (к примеру, в iOS, некоторых смарт-TV и прочем таком). Нам, как бэкенд-разработчикам, знать такое не обязательно, но разве же знания бывают лишними?</p> <p>Итак, V8. Компилирует и выполняет JS-код, работает со стеком, управляет выделением памяти и сборкой мусора, а также обеспечивает нас всеми типами данных, операторами, объектами и функциями.</p> <h4 id="libuv">libuv</h4> <p>К сожалению, V8 не может работать с операционными системами напрямую — это было бы сложно поддерживать (к примеру, у *nix-систем есть проблемы с поддержкой non-blocking I/O-операций, и работа с ними напрямую была бы как минимум крайне нетривиальной задачей). Поэтому приходится использовать библиотеку-посредник между V8 и ОС — собственно, libuv и используется. Удобно, что есть один мультиплатформенный инструмент, реализующий асинхронный ввод-вывод — без такого инструмента существование Node.js было бы попросту невозможно.</p> <h4 id="c---аддоны">C++ - аддоны</h4> <p>Да, для Node.js написано множество аддонов на C++. С помощью них, например, реализованы воркеры, и мы можем в дополнение к основному потоку выполнение разворачивать дополнительные дочерние треды.</p> <h4 id="nodejs---биндинги">Node.js - биндинги</h4> <p>Для того, чтобы связываться и работать с какими-то внешними штуками, Node.js нужны биндинги — по сути, это библиотеки, которые позволяют нам использовать библиотеки, написанные на других языках, вместе с Node.js. Это нужно, к примеру, для разного рода I/O: соединение с базами данных, файловыми системами и прочими такими штуками.</p> <h3 id="event-loop">Event Loop</h3> <p>И вот теперь, наконец, мы подошли к главному, к тому, ради чего эта статья и затевалась — к возможности ответить на вопрос, как же все-таки Node.js выполняет неблокирующие (асинхронные операции ввода-вывода, несмотря на то, что он однопоточный — оказывается, он с помощью libuv отдает множество работы операционной системе.</p> <p>Учитывая то, что большинство современных ядер ОС многопоточны, они могут выполнять множество операций одновременно в фоне. Когда какая-то из этих операций завершается, ядро операционной системы дает об этом знать Node.js, чтобы соответствующий коллбек мог быть добавлен в poll-очередь (мы объясним, что это, чуть позже), чтобы со временем быть выполненным.</p> <p>Итак, когда Node.js запускается, он запускает event loop и исполняет входящий скрипт, который может выполнять асинхронные запросы к API, планировать таймеры или вызывать <code class="language-plaintext highlighter-rouge">process.nextTick()</code>, после чего начинает исполнять цикл событий (собственно, event loop).</p> <p>Давайте для начала вкратце определимся, как примерно работает event loop, что такое микротаски и макротаски, а затем разберем фазы event loop.</p> <h4 id="микротаски-и-макротаски">Микротаски и макротаски</h4> <p>Помимо обычных синхронных задач, в JS существуют так называемые микротаски и макротаски.</p> <p>Микротаски имеют приоритет над макротасками, и, пока выполняются задачи из очереди микротасок, до макротасок дело не дойдет. Микротаски — это промисы, то, что запланировано с помощью <code class="language-plaintext highlighter-rouge">process.nextTick()</code> и <code class="language-plaintext highlighter-rouge">queueMicrotack()</code>, в браузере — еще и результат работы <code class="language-plaintext highlighter-rouge">MutationObserver</code> (вкратце — такая штука, генерящая уведомления об изменении определенных DOM-элементов). Макротаски — это то, что выполняется только тогда, когда очередь микротасок пуста. Это то, что мы планируем с помощью <code class="language-plaintext highlighter-rouge">setTimeout()</code>, <code class="language-plaintext highlighter-rouge">setImmediate()</code>, <code class="language-plaintext highlighter-rouge">setInterval()</code>, в браузере — еще и рендеринг. С учетом того, что микротаски блокируют выполнение макротасок, напрашивается очевидный вывод — не стоит забивать очередь микротасок, иначе мы заблокируем все макротаски.</p> <p>Если вкратце, event loop работает так: выполняет микротаски, пока они есть, ставя себя на паузу, затем продолжается, исполняет макротаску и возвращается к микротаскам.</p> <h4 id="фазы-event-loop">Фазы Event Loop</h4> <p>Для начала — коротко перечислим все эти фазы и объясним, что в них происходит, после чего перейдем к деталям.</p> <ul> <li>timers - в этой фазе исполняются коллбеки, запланированные с помощью <code class="language-plaintext highlighter-rouge">setTimeout()</code> и <code class="language-plaintext highlighter-rouge">setInterval()</code> </li> <li>pending callbacks - выполняются коллбеки ввода/вывода, отложенные до следующей итерации цикла событий</li> <li>idle, prepare - используются исключительно для внутренних нужд</li> <li>poll - получаются новые события ввода/вывода, выполняются связанные с вводом/выводом коллбеки (почти все, за исключением тех, которые запланированы таймерами и <code class="language-plaintext highlighter-rouge">setImmediate()</code>). Поток будет блокироваться здесь, когда это уместно. Тут мы как раз работаем с очередью микротасок.</li> <li>check - <code class="language-plaintext highlighter-rouge">setImmediate()</code> - коллбеки вызываются здесь</li> <li>close callbacks - закрываются некоторые коллбеки типа socket.on(‘close’, …)</li> </ul> <p>Между каждым запуском цикла событий, Node.js проверяет, не ожидает ли он каких-то асинхронных операций ввода-вывода, таймеров и останавливается без ошибок, если ничего не ожидается.</p> <p>Давайте разбирать эти фазы чуть подробнее.</p> <h4 id="timers">timers</h4> <p>Таймер указывает некий порог времени, после которого коллбек может быть выполнен, это не точное время, через которое коллбек точно выполнится. Коллбеки таймеров будут запущены так рано, как могут, после того, как указанное в таймере время пройдет — однако, планирование ОС или выполнение других коллбеков может отложить их выполнение.</p> <p>На самом деле, фаза poll контролирует, когда таймеры выполняются. К примеру, скажем, вы запланировали таймаут так, чтобы он выполнился после задержки в 100 мс, а потом ваш скрипт начинает асинхронно читать файл, что занимает 95 мс. Когда event loop входит в фазу poll, его очередь пуста (<code class="language-plaintext highlighter-rouge">fs.readFile()</code>еще не выполнена), так что он подождет то количество миллисекунд, которого хватит для выполнения ближайшего по времени таймера. Пока event loop ждет 95 миллисекунд, <code class="language-plaintext highlighter-rouge">fs.readFile()</code> заканчивает читать файл, и его коллбек, которому требуется 10 мс для выполнения добавляется в очередь poll и выполняется. Когда он заканчивает выполнение, в очереди больше нет коллбеков, поэтому event loop увидит, что порог ближайшего таймера достигнут, и вернется к фазе таймеров, чтобы выполнить коллбек таймера. Таким образом, в этом примере общая задержка между планированием таймера и выполнением его коллбека составит 105 мс.</p> <p>Чтобы перебор микротасок не приводил к тому, чтобы в event loop ничего не поступало, библиотека <code class="language-plaintext highlighter-rouge">libuv</code> тоже имеет зависимое от ОС ограничение максимального количества ивентов, прежде чем она прекратит запрашивать новые события.</p> <h4 id="pending-callbacks">pending callbacks</h4> <p>На этом этапе выполняются коллбеки для разного рода системных операций. К примеру, если TCP-сокет получает ошибку <code class="language-plaintext highlighter-rouge">ECONNREFUSED</code> (в соединении отказано), некоторые *nix-системы захотят подождать перед тем, как сообщить об ошибке. Это и уйдет в очередь, чтобы выполниться в фазе pending callbacks.</p> <h4 id="poll">poll</h4> <p>Фаза poll имеет два основных назначения:</p> <ul> <li>вычислить, сколько I/O будет блокировать поток</li> <li>обработать события в poll queue</li> </ul> <p>Когда event loop переходит в фазу poll и нет ни одного запланированного таймера, случится что-то из этого:</p> <ul> <li>если очередь микротасок не пуста, event loop пройдется по очереди микротасок, выполняя их синхронно до тех пор, пока либо очередь не опустеет, либо не будет достигнут тот самый лимит на максимальное количество ивентов в libuv</li> <li>если же очередь микротасок пуста, произойдет еще одно из двух событий: <ul> <li>если что-то было запланировано с помощью <code class="language-plaintext highlighter-rouge">setImmediate()</code>, event loop закончит poll-фазу и выполнит то, что было запланировано</li> <li>если ничего не было запланировано с помощью <code class="language-plaintext highlighter-rouge">setImmediate()</code>, event loop подождет, пока коллбеки добавятся в очередь, и немедленно их выполнит</li> </ul> </li> </ul> <p>Как только очередь микротасок опустеет, event loop проверит наличие таймеров, пороговые значения которых был достигнуты. Если один или несколько таймеров доступны, event loop вернется к фазе timers и выполнит коллбеки этих таймеров.</p> <h4 id="check">check</h4> <p>Фаза check позволяет исполнять коллбеки сразу же после того, как фаза poll завершена. Если фаза poll простаивает, и что-то запланировано с помощью <code class="language-plaintext highlighter-rouge">setImmediate()</code>, event loop может продолжиться до фазы check вместо того, чтобы ждать.</p> <p>На самом деле, <code class="language-plaintext highlighter-rouge">setImmediate()</code> — это такой специальный таймер, который запускается в отдельной фазе event loop. Он использует API <code class="language-plaintext highlighter-rouge">libuv</code>, чтобы планировать коллбеки к выполнению после завершения poll-фазы.</p> <p>Как правило, по мере выполнения event loop в итоге переходит к фазе poll, где он будет ожидать входящего соединения, запроса или чего-то вроде того. Впрочем, если коллбек был запланирован с помощью <code class="language-plaintext highlighter-rouge">setImmediate()</code>, а фаза poll бездействует, она завершится и перейдет к фазе check вместо того≤ чтобы ждать poll-событий.</p> <h4 id="close-callbacks">close callbacks</h4> <p>Если сокет или дескриптор внезапно закроются, ивент ‘close’ будет сгенерирован на этом этапе. Иначе он будет отправлен через <code class="language-plaintext highlighter-rouge">process.nextTick()</code>.</p> <h4 id="setimmediate-vs-settimeout">setImmediate() vs setTimeout()</h4> <p><code class="language-plaintext highlighter-rouge">setImmediate()</code> и <code class="language-plaintext highlighter-rouge">setTimeout()</code> очень похожи, но ведут себя немного по-разному в зависимости от того, когда они вызваны.</p> <ul> <li> <code class="language-plaintext highlighter-rouge">setImmediate()</code> выполнит то, что запланировано, как только текущая poll-фаза будет завершена</li> <li> <code class="language-plaintext highlighter-rouge">setTimeout</code> выполнит запланированное после того, как минимальная указанная задержка в миллисекундах истечет</li> </ul> <p>Порядок, в котором выполняются таймеры, зависит от контекста, в котором они вызываются. Если оба вызываются из основного модуля, то время будет зависеть от производительности процесса.</p> <p>Например, если мы запустим вот этот скрипт, который не находится в I/O-цикле (то есть, в основном модуле) , порядок, в котором они выполнятся, неопределен, поскольку связан с производительностью процесса:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// timeout_vs_immediate.js</span>
<span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">timeout</span><span class="dl">'</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">0</span><span class="p">);</span>

<span class="nx">setImmediate</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">immediate</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>node timeout_vs_immediate.js
<span class="nb">timeout
</span>immediate

<span class="nv">$ </span>node timeout_vs_immediate.js
immediate
<span class="nb">timeout</span>
</code></pre></div></div> <p>Однако, если мы эти вызовы закинем в цикл I/O, коллбек <code class="language-plaintext highlighter-rouge">setImmediate()</code> всегда выполнится первым:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// timeout_vs_immediate.js</span>
<span class="kd">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">fs</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="nx">__filename</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">timeout</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
  <span class="nx">setImmediate</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">immediate</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>
</code></pre></div></div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>node timeout_vs_immediate.js
immediate
<span class="nb">timeout</span>

<span class="nv">$ </span>node timeout_vs_immediate.js
immediate
<span class="nb">timeout</span>
</code></pre></div></div> <p>Главное преимущество <code class="language-plaintext highlighter-rouge">setImmediate()</code> — это то, что оно всегда будет выполнено перед всеми таймерами внутри I/O-цикла, вне зависимости от того, как много таймеров существует.</p> <h4 id="processnexttick-vs-setimmmediate">process.nextTick() vs setImmmediate()</h4> <p>У нас есть две штуки, похожие друг на друга, но их названия могут нас путать.</p> <p><code class="language-plaintext highlighter-rouge">process.nextTick()</code> срабатывает сразу же на тоей же фазе event loop. <code class="language-plaintext highlighter-rouge">setImmediate()</code> срабатывает на следующей итерации / “тике” event loop. Выглядит так, что имена функций нужно обменять местами.</p> <p><code class="language-plaintext highlighter-rouge">process.nextTick()</code> срабатывает быстрее, чем <code class="language-plaintext highlighter-rouge">setImmediate()</code>, но это легаси, и это вряд ли изменится — если это поменять, мы сломаем огромное количество пакетов в <code class="language-plaintext highlighter-rouge">npm</code>. Каждый день в <code class="language-plaintext highlighter-rouge">npm</code> добавляются новые модули, каждый день добавляется больше потенциальных поломок. Имена могут сбивать с толку, но они не изменятся.</p> <p>Рекомендуется во всех случаях использовать <code class="language-plaintext highlighter-rouge">setImmediate()</code> и забыть о <code class="language-plaintext highlighter-rouge">process.nextTick()</code>. Совсем.</p> <h4 id="но-в-каких-случаях-использовать-processnexttick">Но в каких случаях использовать process.nextTick()?</h4> <p>Есть две причины:</p> <ol> <li>Разрешить пользователям обрабатывать ошибки, очищать все ненужные ресурсы или, возможно, повторить запрос снова перед тем, как event loop продолжится.</li> <li>Иногда нам нужно разрешить выполнение коллбека после раскручивания стека вызовов, но до продолжения event loop.</li> </ol> <p>Вот пример:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">server</span> <span class="o">=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">createServer</span><span class="p">();</span>
<span class="nx">server</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">connection</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">conn</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{});</span>

<span class="nx">server</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="mi">8080</span><span class="p">);</span>
<span class="nx">server</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">listening</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{});</span>
</code></pre></div></div> <p>Предположим, что <code class="language-plaintext highlighter-rouge">listen</code> запускается в начале event loop, но коллбек <code class="language-plaintext highlighter-rouge">listening</code> помещен в <code class="language-plaintext highlighter-rouge">setImmediate()</code>.Если имя хоста не передано, привязка к порту произойдет немедленно. Чтобы event loop продолжился, он лджлжен добраться до фазы poll — то есть существует ненулевая вероятность, что мы получим соединение и запустим событие <code class="language-plaintext highlighter-rouge">connection</code> до события <code class="language-plaintext highlighter-rouge">listening</code>.</p> <p>Вот другой пример — расширение <code class="language-plaintext highlighter-rouge">EventEmitter</code> и отправка события из конструктора:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">EventEmitter</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">events</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">class</span> <span class="nx">MyEmitter</span> <span class="kd">extends</span> <span class="nx">EventEmitter</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">();</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="dl">'</span><span class="s1">event</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">myEmitter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyEmitter</span><span class="p">();</span>
<span class="nx">myEmitter</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">event</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">an event occurred!</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div> <p>Нельзя сгенерировать событие из конструктора, поскольку скрипт не будет обработан до момента, когда пользователь назначает коллбек этому ивенту. Таким образом, внутри самого конструктора мы можем использовать <code class="language-plaintext highlighter-rouge">process.nextTick()</code>, чтобы установить коллбек для отправки <code class="language-plaintext highlighter-rouge">event</code> после того, как конструктор завершен — то есть все произойдет так, как мы и ожидаем.</p> <h2 id="выводы">Выводы</h2> <p>Асинхронность — важнейшая тема в JavaScript. Понимая все тонкости того, как все это работает изнутри, можно писать гораздо более предсказуемый и производительный код. И да, есть соблазн пропустить к чертям теорию, попытавшись не вникать в теорию (которая и вправду сложна) — но я бы крайне рекомендовал вникнуть в теорию, это даст вам возможность писать код намного более осознанно. И да, о теории — напоследок я порекомендую <a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" rel="external nofollow noopener" target="_blank">вот это</a> выступление Филиппа Робертса с JSConf о event loop — в дополнение к этой статье это добавит вам понимания того, как все-таки однопоточный JavaScript работает асинхронно и очень быстро. Enjoy</p> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2023 Сослан Х. Алдатов. Лежит на <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Бронируйте встречи на <a href="https://sptm.dev/meetme" target="_blank" rel="external nofollow noopener">моем Fantastical Openings</a>. Фото стянуты в том числе из <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-P58WVSR9JS"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-P58WVSR9JS");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>