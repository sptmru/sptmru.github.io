<!DOCTYPE html> <html lang="ru"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content="352510442"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>SOLID, GRASP и другие принципы разработки | Всякое о JS на бэкенде</title> <meta name="author" content="Сослан Х. Алдатов"> <meta name="description" content="Статья о шаблонах и принципах проектирования — больше об ООП, чуть меньше о JS."> <meta name="keywords" content="sptm, sptmru, Soslan Aldatov, Node.js, JavaScript, backend, mentor, mentoring"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700%7CRoboto+Slab:100,300,400,500,700%7CMaterial+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://sptmru.github.io/2023/solid-grasp-and-stuff/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">главная</a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">репозитории</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">менторинг</a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">блог <span class="sr-only">(current)</span> </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">SOLID, GRASP и другие принципы разработки</h1> <p class="post-meta">February 7, 2023</p> <p class="post-tags"> <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/blog/tag/theory"> <i class="fas fa-hashtag fa-sm"></i> theory</a>     ·   <a href="/blog/category/theory"> <i class="fas fa-tag fa-sm"></i> theory</a>   </p> </header> <article class="post-content"> <p>Собственно, да, об этом и статья. Конечно, знание этих принципов делает нас, как разработчиков, лучше (а собеседования — проще). Но стоит помнить: мы в Node.js не всегда пишем в чистом ООП-стиле, и эти принципы не всегда имеют изначально заложенный в них смысл в Node.js-разработке.</p> <p>Но давайте сначала разберемся, о чем речь, а потом будем решать, полезно нам оно или нет.</p> <h2 id="solid">SOLID</h2> <p>Когда-то, в начале 2000-x, небезызвестный Роберт Мартин назвал пять основных принципов объектно-ориентированного программирования, а чуть менее известный Майкл Фэзерс составил из них акроним. Давайте разберем акроним обратно и подробнее остановимся на каждой букве.</p> <h3 id="s-single-responsibility-protocol-принцип-единственной-ответственности">S: Single Responsibility Protocol (принцип единственной ответственности)</h3> <p>Принцип звучит примерно так: для каждого класса должно быть определено единственное назначение. Все ресурсы, необходимые для его осуществления, должны быть инкапсулированы в этот класс и подчинены только этой задаче. Есть еще одна формулировка: “Класс должен иметь одну и только одну причину для изменения”.</p> <p>Если представить себе крайнюю степень нарушения этого принципа, то мы получим антипаттерн “God Object”, “божественный объект”, то есть класс, который делает сразу все, содержит в себе сразу все и невероятно сложен для изменения, поскольку одно изменение в одной его части может повлиять на другие части класса и на другие классы, его использующие — соотвественно, на все приложение. Конечно, так делать не нужно, в том числе в JS.</p> <p>Есть одна проблема: если не рассматривать TypeScript, то Node.js не очень-то умеет в инкапсуляцию, приватные свойства и методы просто не существуют в JS и становятся предметом договоренностей (вроде “а давайте именовать приватные свойства и методы, начиная с подчеркивания”). Это не то чтобы проблема, спасибо линтерам, но я счел нужным об этом упомянуть. В остальном — да, давайте писать наши классы (или объекты, если мы не используем ООП) так, чтобы они имели только одно назначение и только одну причину для изменений.</p> <h3 id="o-open-closed-principle-принцип-открытости-закрытости">O: Open-Closed Principle (принцип открытости-закрытости)</h3> <p>Формулируется этот принцип так: “Программные сущности (классы, модули, объекты, функции и так далее) должны быть открыты для расширения, но закрыты для изменения”. Собственно, в классическом ООП это значит примерно то, что мы должны предпочитать создание дочерних сущностей для расширения функциональности объекта вместо того, чтобы изменять родительский объект для достижения этой цели.</p> <p>И да, этот принцип (с поправкой на использование абстрактных интерфейсов и наследования от них вместо наследования от родительского класса) вполне реализуем и имеет смысл в TypeScript. Но даже там гораздо логичнее отказаться от наследования, которое работает достаточно странно и опасно в JS — вместо этого можно использовать композицию, используя принцип “composition over inheritance”. Это еще и гораздо более гибко. Смотрите:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// наследование</span>

<span class="kd">class</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="nx">eat</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">I am eating</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">breathe</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">I am breathing</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">swim</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">I am swimming</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Magician</span> <span class="kd">extends</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="nx">trick</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">I am doing a trick</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">liv</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Magician</span><span class="p">();</span>
<span class="kd">const</span> <span class="nx">harry</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Magician</span><span class="p">();</span>

<span class="c1">//Liv can:</span>
<span class="nx">liv</span><span class="p">.</span><span class="nx">eat</span><span class="p">();</span>
<span class="nx">liv</span><span class="p">.</span><span class="nx">breathe</span><span class="p">();</span>
<span class="nx">liv</span><span class="p">.</span><span class="nx">swim</span><span class="p">();</span>
<span class="nx">liv</span><span class="p">.</span><span class="nx">trick</span><span class="p">();</span>
<span class="c1">//I am eating</span>
<span class="c1">//I am breathing</span>
<span class="c1">//I am swimming</span>
<span class="c1">//I am doing a trick</span>
<span class="c1">//Harry can:</span>
<span class="nx">harry</span><span class="p">.</span><span class="nx">eat</span><span class="p">();</span>
<span class="nx">harry</span><span class="p">.</span><span class="nx">breathe</span><span class="p">();</span>
<span class="nx">harry</span><span class="p">.</span><span class="nx">swim</span><span class="p">();</span>
<span class="nx">harry</span><span class="p">.</span><span class="nx">trick</span><span class="p">();</span>
<span class="c1">//I am eating</span>
<span class="c1">//I am breathing</span>
<span class="c1">//I am swimming</span>
<span class="c1">//I am doing a trick</span>

</code></pre></div></div> <p>В чем проблема кода выше? Мы не можем сделать так, чтобы Magician не наследовал все методы родительского класса Person. Мы можем сократить количество методов в Person, насоздавать кучу классов под разные нужды…а можем сделать вот так:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// композиция</span>

<span class="kd">const</span> <span class="nx">eat</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="na">eat</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">I am eating</span><span class="dl">'</span><span class="p">);</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">const</span> <span class="nx">breathe</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="na">breathe</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">I am breathing</span><span class="dl">'</span><span class="p">);</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">const</span> <span class="nx">swim</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="na">swim</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">I am swimming</span><span class="dl">'</span><span class="p">);</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">const</span> <span class="nx">trick</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="na">trick</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">I am doing a trick</span><span class="dl">'</span><span class="p">);</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">nonEatingMagician</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span>
     <span class="p">{},</span>
     <span class="nx">breathe</span><span class="p">(),</span>
     <span class="nx">trick</span><span class="p">(),</span>
   <span class="p">);</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">nonSwimmingPerson</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span>
    <span class="p">{},</span>
    <span class="nx">eat</span><span class="p">(),</span>
    <span class="nx">breathe</span><span class="p">(),</span>
  <span class="p">)</span> 
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">nonSwimmingMagician</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span>
    <span class="p">{},</span>
    <span class="nx">eat</span><span class="p">(),</span>
    <span class="nx">breathe</span><span class="p">(),</span>
    <span class="nx">trick</span><span class="p">(),</span>
  <span class="p">)</span> 
<span class="p">}</span>
</code></pre></div></div> <p>Видите, насколько это гибко? И разве же это нарушает суть принципа открытости / закрытости? В общем, что я хочу сказать: предпочитайте композицию наследованию, и вы автоматически будете соблюдать принцип открытости / закрытости.</p> <h3 id="l-liskov-substitution-principle-принцип-подстановки-барбары-лисков">L: Liskov Substitution Principle (Принцип подстановки Барбары Лисков)</h3> <p>Барбара Лисков, американская ученая, в далеком 1987 году сформулировала этот принцип подстановки так: “Пусть q(x) является свойством, верным относительно объектов x некоторого типа T. Тогда q(y) также должно быть верным для объектов y типа S, где S — подтип типа T”. И спасибо дядюшке Бобу за то, что он переформулировал это гораздо понятнее:</p> <p>“Объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы”. Так понятнее, да? Вот только что с этим делать в чистом JS? Как мы можем гарантировать, что объект — подтип другого объекта? Я не вижу применения этому принципу в JS. Зато в TypeScript — без проблем:</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">getArea</span><span class="p">(</span><span class="nx">shapes</span><span class="p">:</span> <span class="nx">Shape</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">shapes</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span>
        <span class="p">(</span><span class="nx">previous</span><span class="p">,</span> <span class="nx">current</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">previous</span> <span class="o">+</span> <span class="nx">current</span><span class="p">.</span><span class="nx">area</span><span class="p">(),</span>
        <span class="mi">0</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>Функция getArea без проблем будет работать с любым классом, который реализует интерфейс <code class="language-plaintext highlighter-rouge">Shape</code>.</p> <h3 id="i-interface-segregation-principle-принцип-разделения-интерфейса">I: Interface Segregation Principle (принцип разделения интерфейса)</h3> <p>Тут все просто: чем больше интерфейсов, тем лучше. Вот только есть проблема: в JS нет интерфейсов. С трудом можно натянуть этот принцип на прототипное наследование: чем больше прототипов, тем лучше. Только вот мы уже уговорились забить на наследование в пользу композиции. Поэтому я продемонстрирую этот принцип на TS:</p> <p>Представим, что у нас есть две доменных сущности: <code class="language-plaintext highlighter-rouge">Rectangle</code> и <code class="language-plaintext highlighter-rouge">Circle</code>, реализующих интерфейс <code class="language-plaintext highlighter-rouge">Shape</code>. Интерфейс <code class="language-plaintext highlighter-rouge">Shape</code> требует от наследников реализации метода area(), считающего площадь и явно принадлежащего к бизнес-логике.</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Shape</span> <span class="p">{</span>
    <span class="nx">area</span><span class="p">():</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Rectangle</span> <span class="k">implements</span> <span class="nx">Shape</span> <span class="p">{</span>

    <span class="k">public</span> <span class="nx">width</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="k">public</span> <span class="nx">height</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>

    <span class="k">public</span> <span class="nx">area</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">height</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Circle</span> <span class="k">implements</span> <span class="nx">Shape</span> <span class="p">{</span>

    <span class="k">public</span> <span class="nx">radius</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>

    <span class="k">public</span> <span class="nx">area</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">radius</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">radius</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Предположим, что нам потребовался метод для сериализации этих сущностей, что относится скорее к архитектуре, чем к бизнес-логике: таким образом, мы не можем просто добавить метод <code class="language-plaintext highlighter-rouge">serialize()</code> в интерфейс <code class="language-plaintext highlighter-rouge">Shape</code>, ведь это нарушит принцип единственной ответственности: интерфейс не может отвечать и за бизнес-логику, и за архитектуру. Что мы можем сделать? Добавить больше интерфейсов!</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Shape</span> <span class="p">{</span>
    <span class="nx">area</span><span class="p">():</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">RectangleInterface</span> <span class="p">{</span>
    <span class="nl">width</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="nl">height</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">CircleInterface</span> <span class="p">{</span>
    <span class="nl">radius</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Serializable</span> <span class="p">{</span>
    <span class="nx">serialize</span><span class="p">():</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Rectangle</span> <span class="k">implements</span> <span class="nx">RectangleInterface</span><span class="p">,</span> <span class="nx">Shape</span> <span class="p">{</span>

    <span class="k">public</span> <span class="nx">width</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="k">public</span> <span class="nx">height</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>

    <span class="k">public</span> <span class="nx">area</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">height</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Circle</span> <span class="k">implements</span> <span class="nx">CircleInterface</span><span class="p">,</span> <span class="nx">Shape</span> <span class="p">{</span>

    <span class="k">public</span> <span class="nx">radius</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>

    <span class="k">public</span> <span class="nx">area</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">radius</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">radius</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div> <p>Видите, что произошло? Большее количество интерфейсов позволило нам разделить бизнес-логику и архитектуру. В TS это возможно. В JS — нет.</p> <h3 id="d-dependency-inversion-principle-принцип-инверсии-зависимости">D: Dependency Inversion Principle (принцип инверсии зависимости)</h3> <p>Сформулировать этот принцип можно примерно так: “Классы должны зависеть от абстракций, а не от конкретных деталей”. Опять! Абстракции в JS? Не слышал о таком. А в TS — без проблем, знай подсовывай интерфейсы классам в качестве зависимостей.</p> <h3 id="solid-итоги">SOLID: итоги</h3> <p>SOLID очень завязан на ООП, которого в полноценном виде нет в JS. Мы можем (и должны) сверяться с SOLID при написании ООП-кода, но, к примеру, в функциональном стиле программирования (который вполне себе мы можем использовать в JS) нет места большинству принципов SOLID (да всем, кроме первого, наверное). Другое дело — TypeScript, который позволяет и поощряет программирование в ООП-стиле — и для него все эти принципы вполне актуальны.</p> <p>Рассмотрим набор шаблонов, который ощутимо меньше цепляется за ООП — GRASP.</p> <h2 id="grasp">GRASP</h2> <p>General responsibility assignment software patterns. Так этот GRASP расшифровывается. Общие шаблоны распределения ответственностей. Заметьте, и в SOLID многое было посвящено распределению ответственностей — заставляет задуматься, насколько это важно в разработке ПО. Ну да ладно.</p> <p>GRASP — это девять шаблонов распределения ответственностей. Давайте разберем их.</p> <ol> <li> <p>Information Expert (Информационный эксперт).</p> <p>Информационный эксперт — это штука, связанная с S в SOLID. Звучит описание шаблона примерно так: “Ответственность должна быть назначена тому, кто владеет максимумом информации для исполнения — информационному эксперту”. То есть, класс (или объект), владеющий максимумом информации о некой доменной области, должен отвечать и за исполнение задач этой доменной области. По сути, тот же принцип единственной ответственности.</p> </li> <li> <p>Creator (Создатель).</p> <p>Если вы слышали о паттерне проектирования “фабрика”/”абстрактная фабрика”, то это оно. Точнее, не совсем оно. Этот шаблон отвечает на вопрос “кто (какая фабрика) должен создавать объекты некоторого типа А?”. И отвечает он так: назначить объекту B создавать объекты А, если:</p> <ul> <li>содержит или агрегирует объекты A; <ul> <li>записывает объекты A;</li> <li>активно использует объекты A;</li> <li>обладает данными для создания объектов A;</li> </ul> </li> </ul> <p>Ну, то есть, ответственность за создание объектов A должна быть назначена тому, кто владеет максимумом информации для исполнения. Выходит, что по отношению к объектам A объект B — информационный эксперт.</p> </li> <li> <p>Controller (Контроллер).</p> <p>Та самая буква C в паттерне MVC. Штука, которая отвечает за прием запросов от пользователя и делегирование их исполнения соответствующим информационным экспертам.</p> </li> <li> <p>Low Coupling (Низкое связывание).</p> <p>Этот шаблон немного связан с буквой I в SOLID (да и с буквой S тоже). Речь о том, что объекты (классы) должны быть слабо связаны и как можно более независимы друг от друга в смысле внесения изменений (в идеале, во вполне достижимом идеале, полностью независимы).</p> </li> <li> <p>High Cohesion (Высокая связность).</p> <p>Тут речь о том, что обязанности данного элемента тесно связаны и сфокусированы. Разбиение программ на классы и подсистемы является примером деятельности, которая увеличивает связность системы.</p> </li> <li> <p>Polymorphism (Полиморфизм)</p> <p>Да, тот самый, из ООП. Реализуется в том числе паттернами “Адаптер” и “Стратегия”, и в целом говорит нам о том, что разные объекты могут наследоваться от одних и тех же интерфейсов, реализуя их методы по-разному. Помним о буковке I в SOLID.</p> </li> <li> <p>Pure Fabrication (Чистая выдумка).</p> <p>О чем здесь речь? Да практически о том, о чем и в шаблоне Creator. Стоит задача: создавать объекты A, не используя средства класса A. Решение: создать Creator (создать создателя, лол) для класса A.</p> </li> <li> <p>Redirection (Перенаправление).</p> <p>Хороший пример перенаправления — шаблон “Контроллер”, который становится посредником между моделью и представлением в паттерне MVC, таким образом реализуя шаблон Low Coupling, уменьшая связывание между классами.</p> </li> <li> <p>Устойчивость к изменениям (Protected Variations).</p> <p>И тут все тоже довольно просто: надо объектам взаимодействовать? Пусть взаимодействуют через специально для этого созданный интерфейс. Пример шаблона Redirection, тоже уменьшает связность.</p> </li> </ol> <h3 id="grasp-выводы">GRASP. Выводы</h3> <p>Оно вроде все тоже про ООП, да? Но понятия связности и ответственности есть в любой системе, и мы должны учитывать эти шаблоны при разработке в том числе на JS.</p> <h2 id="dry">DRY</h2> <p>Тут все просто: Don’t repeat yourself. Не надо копипастить код, это антипаттерн. Выносите несколько раз используемый код в методы. Только если это не нарушает SOLID и GRASP.</p> <h2 id="выводы">Выводы</h2> <p>ООП-принципы в большинстве своем применимы к JS и полностью применимы к TS. И учить их надо не только для прохождения собесов :)</p> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2023 Сослан Х. Алдатов. Лежит на <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Бронируйте встречи на <a href="https://sptm.dev/meetme" target="_blank" rel="external nofollow noopener">моем Fantastical Openings</a>. Фото стянуты в том числе из <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-P58WVSR9JS"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-P58WVSR9JS");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>