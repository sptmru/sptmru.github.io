<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ru"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://sptmru.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://sptmru.github.io/" rel="alternate" type="text/html" hreflang="ru"/><updated>2023-02-07T08:50:56+04:00</updated><id>https://sptmru.github.io/feed.xml</id><title type="html">Всякое о JS на бэкенде</title><subtitle>Меня зовут Сослан, и это мой личный сайт. Вообще, он создан, чтоб постить сюда всякое о Node.js и бэкенде в целом. </subtitle><entry><title type="html">SOLID, GRASP и другие принципы разработки</title><link href="https://sptmru.github.io/2023/solid-grasp-and-stuff/" rel="alternate" type="text/html" title="SOLID, GRASP и другие принципы разработки"/><published>2023-02-07T08:30:43+04:00</published><updated>2023-02-07T08:30:43+04:00</updated><id>https://sptmru.github.io/2023/solid-grasp-and-stuff</id><content type="html" xml:base="https://sptmru.github.io/2023/solid-grasp-and-stuff/"><![CDATA[<p>Собственно, да, об этом и статья. Конечно, знание этих принципов делает нас, как разработчиков, лучше (а собеседования — проще). Но стоит помнить: мы в Node.js не всегда пишем в чистом ООП-стиле, и эти принципы не всегда имеют изначально заложенный в них смысл в Node.js-разработке.</p> <p>Но давайте сначала разберемся, о чем речь, а потом будем решать, полезно нам оно или нет.</p> <h2 id="solid">SOLID</h2> <p>Когда-то, в начале 2000-x, небезызвестный Роберт Мартин назвал пять основных принципов объектно-ориентированного программирования, а чуть менее известный Майкл Фэзерс составил из них акроним. Давайте разберем акроним обратно и подробнее остановимся на каждой букве.</p> <h3 id="s-single-responsibility-protocol-принцип-единственной-ответственности">S: Single Responsibility Protocol (принцип единственной ответственности)</h3> <p>Принцип звучит примерно так: для каждого класса должно быть определено единственное назначение. Все ресурсы, необходимые для его осуществления, должны быть инкапсулированы в этот класс и подчинены только этой задаче. Есть еще одна формулировка: “Класс должен иметь одну и только одну причину для изменения”.</p> <p>Если представить себе крайнюю степень нарушения этого принципа, то мы получим антипаттерн “God Object”, “божественный объект”, то есть класс, который делает сразу все, содержит в себе сразу все и невероятно сложен для изменения, поскольку одно изменение в одной его части может повлиять на другие части класса и на другие классы, его использующие — соотвественно, на все приложение. Конечно, так делать не нужно, в том числе в JS.</p> <p>Есть одна проблема: если не рассматривать TypeScript, то Node.js не очень-то умеет в инкапсуляцию, приватные свойства и методы просто не существуют в JS и становятся предметом договоренностей (вроде “а давайте именовать приватные свойства и методы, начиная с подчеркивания”). Это не то чтобы проблема, спасибо линтерам, но я счел нужным об этом упомянуть. В остальном — да, давайте писать наши классы (или объекты, если мы не используем ООП) так, чтобы они имели только одно назначение и только одну причину для изменений.</p> <h3 id="o-open-closed-principle-принцип-открытости-закрытости">O: Open-Closed Principle (принцип открытости-закрытости)</h3> <p>Формулируется этот принцип так: “Программные сущности (классы, модули, объекты, функции и так далее) должны быть открыты для расширения, но закрыты для изменения”. Собственно, в классическом ООП это значит примерно то, что мы должны предпочитать создание дочерних сущностей для расширения функциональности объекта вместо того, чтобы изменять родительский объект для достижения этой цели.</p> <p>И да, этот принцип (с поправкой на использование абстрактных интерфейсов и наследования от них вместо наследования от родительского класса) вполне реализуем и имеет смысл в TypeScript. Но даже там гораздо логичнее отказаться от наследования, которое работает достаточно странно и опасно в JS — вместо этого можно использовать композицию, используя принцип “composition over inheritance”. Это еще и гораздо более гибко. Смотрите:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// наследование</span>

<span class="kd">class</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="nx">eat</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">I am eating</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">breathe</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">I am breathing</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">swim</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">I am swimming</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Magician</span> <span class="kd">extends</span> <span class="nx">Person</span> <span class="p">{</span>
  <span class="nx">trick</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">I am doing a trick</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">liv</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Magician</span><span class="p">();</span>
<span class="kd">const</span> <span class="nx">harry</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Magician</span><span class="p">();</span>

<span class="c1">//Liv can:</span>
<span class="nx">liv</span><span class="p">.</span><span class="nx">eat</span><span class="p">();</span>
<span class="nx">liv</span><span class="p">.</span><span class="nx">breathe</span><span class="p">();</span>
<span class="nx">liv</span><span class="p">.</span><span class="nx">swim</span><span class="p">();</span>
<span class="nx">liv</span><span class="p">.</span><span class="nx">trick</span><span class="p">();</span>
<span class="c1">//I am eating</span>
<span class="c1">//I am breathing</span>
<span class="c1">//I am swimming</span>
<span class="c1">//I am doing a trick</span>
<span class="c1">//Harry can:</span>
<span class="nx">harry</span><span class="p">.</span><span class="nx">eat</span><span class="p">();</span>
<span class="nx">harry</span><span class="p">.</span><span class="nx">breathe</span><span class="p">();</span>
<span class="nx">harry</span><span class="p">.</span><span class="nx">swim</span><span class="p">();</span>
<span class="nx">harry</span><span class="p">.</span><span class="nx">trick</span><span class="p">();</span>
<span class="c1">//I am eating</span>
<span class="c1">//I am breathing</span>
<span class="c1">//I am swimming</span>
<span class="c1">//I am doing a trick</span>

</code></pre></div></div> <p>В чем проблема кода выше? Мы не можем сделать так, чтобы Magician не наследовал все методы родительского класса Person. Мы можем сократить количество методов в Person, насоздавать кучу классов под разные нужды…а можем сделать вот так:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// композиция</span>

<span class="kd">const</span> <span class="nx">eat</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="na">eat</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">I am eating</span><span class="dl">'</span><span class="p">);</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">const</span> <span class="nx">breathe</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="na">breathe</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">I am breathing</span><span class="dl">'</span><span class="p">);</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">const</span> <span class="nx">swim</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="na">swim</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">I am swimming</span><span class="dl">'</span><span class="p">);</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">const</span> <span class="nx">trick</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="na">trick</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">I am doing a trick</span><span class="dl">'</span><span class="p">);</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">nonEatingMagician</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span>
     <span class="p">{},</span>
     <span class="nx">breathe</span><span class="p">(),</span>
     <span class="nx">trick</span><span class="p">(),</span>
   <span class="p">);</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">nonSwimmingPerson</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span>
    <span class="p">{},</span>
    <span class="nx">eat</span><span class="p">(),</span>
    <span class="nx">breathe</span><span class="p">(),</span>
  <span class="p">)</span> 
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">nonSwimmingMagician</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span>
    <span class="p">{},</span>
    <span class="nx">eat</span><span class="p">(),</span>
    <span class="nx">breathe</span><span class="p">(),</span>
    <span class="nx">trick</span><span class="p">(),</span>
  <span class="p">)</span> 
<span class="p">}</span>
</code></pre></div></div> <p>Видите, насколько это гибко? И разве же это нарушает суть принципа открытости / закрытости? В общем, что я хочу сказать: предпочитайте композицию наследованию, и вы автоматически будете соблюдать принцип открытости / закрытости.</p> <h3 id="l-liskov-substitution-principle-принцип-подстановки-барбары-лисков">L: Liskov Substitution Principle (Принцип подстановки Барбары Лисков)</h3> <p>Барбара Лисков, американская ученая, в далеком 1987 году сформулировала этот принцип подстановки так: “Пусть q(x) является свойством, верным относительно объектов x некоторого типа T. Тогда q(y) также должно быть верным для объектов y типа S, где S — подтип типа T”. И спасибо дядюшке Бобу за то, что он переформулировал это гораздо понятнее:</p> <p>“Объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы”. Так понятнее, да? Вот только что с этим делать в чистом JS? Как мы можем гарантировать, что объект — подтип другого объекта? Я не вижу применения этому принципу в JS. Зато в TypeScript — без проблем:</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">getArea</span><span class="p">(</span><span class="nx">shapes</span><span class="p">:</span> <span class="nx">Shape</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">shapes</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span>
        <span class="p">(</span><span class="nx">previous</span><span class="p">,</span> <span class="nx">current</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">previous</span> <span class="o">+</span> <span class="nx">current</span><span class="p">.</span><span class="nx">area</span><span class="p">(),</span>
        <span class="mi">0</span>
    <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>Функция getArea без проблем будет работать с любым классом, который реализует интерфейс <code class="language-plaintext highlighter-rouge">Shape</code>.</p> <h3 id="i-interface-segregation-principle-принцип-разделения-интерфейса">I: Interface Segregation Principle (принцип разделения интерфейса)</h3> <p>Тут все просто: чем больше интерфейсов, тем лучше. Вот только есть проблема: в JS нет интерфейсов. С трудом можно натянуть этот принцип на прототипное наследование: чем больше прототипов, тем лучше. Только вот мы уже уговорились забить на наследование в пользу композиции. Поэтому я продемонстрирую этот принцип на TS:</p> <p>Представим, что у нас есть две доменных сущности: <code class="language-plaintext highlighter-rouge">Rectangle</code> и <code class="language-plaintext highlighter-rouge">Circle</code>, реализующих интерфейс <code class="language-plaintext highlighter-rouge">Shape</code>. Интерфейс <code class="language-plaintext highlighter-rouge">Shape</code> требует от наследников реализации метода area(), считающего площадь и явно принадлежащего к бизнес-логике.</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Shape</span> <span class="p">{</span>
    <span class="nx">area</span><span class="p">():</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Rectangle</span> <span class="k">implements</span> <span class="nx">Shape</span> <span class="p">{</span>

    <span class="k">public</span> <span class="nx">width</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="k">public</span> <span class="nx">height</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>

    <span class="k">public</span> <span class="nx">area</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">height</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Circle</span> <span class="k">implements</span> <span class="nx">Shape</span> <span class="p">{</span>

    <span class="k">public</span> <span class="nx">radius</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>

    <span class="k">public</span> <span class="nx">area</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">radius</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">radius</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Предположим, что нам потребовался метод для сериализации этих сущностей, что относится скорее к архитектуре, чем к бизнес-логике: таким образом, мы не можем просто добавить метод <code class="language-plaintext highlighter-rouge">serialize()</code> в интерфейс <code class="language-plaintext highlighter-rouge">Shape</code>, ведь это нарушит принцип единственной ответственности: интерфейс не может отвечать и за бизнес-логику, и за архитектуру. Что мы можем сделать? Добавить больше интерфейсов!</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Shape</span> <span class="p">{</span>
    <span class="nx">area</span><span class="p">():</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">RectangleInterface</span> <span class="p">{</span>
    <span class="nl">width</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="nl">height</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">CircleInterface</span> <span class="p">{</span>
    <span class="nl">radius</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Serializable</span> <span class="p">{</span>
    <span class="nx">serialize</span><span class="p">():</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Rectangle</span> <span class="k">implements</span> <span class="nx">RectangleInterface</span><span class="p">,</span> <span class="nx">Shape</span> <span class="p">{</span>

    <span class="k">public</span> <span class="nx">width</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="k">public</span> <span class="nx">height</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>

    <span class="k">public</span> <span class="nx">area</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">height</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Circle</span> <span class="k">implements</span> <span class="nx">CircleInterface</span><span class="p">,</span> <span class="nx">Shape</span> <span class="p">{</span>

    <span class="k">public</span> <span class="nx">radius</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>

    <span class="k">public</span> <span class="nx">area</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">radius</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">radius</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">PI</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div> <p>Видите, что произошло? Большее количество интерфейсов позволило нам разделить бизнес-логику и архитектуру. В TS это возможно. В JS — нет.</p> <h3 id="d-dependency-inversion-principle-принцип-инверсии-зависимости">D: Dependency Inversion Principle (принцип инверсии зависимости)</h3> <p>Сформулировать этот принцип можно примерно так: “Классы должны зависеть от абстракций, а не от конкретных деталей”. Опять! Абстракции в JS? Не слышал о таком. А в TS — без проблем, знай подсовывай интерфейсы классам в качестве зависимостей.</p> <h3 id="solid-итоги">SOLID: итоги</h3> <p>SOLID очень завязан на ООП, которого в полноценном виде нет в JS. Мы можем (и должны) сверяться с SOLID при написании ООП-кода, но, к примеру, в функциональном стиле программирования (который вполне себе мы можем использовать в JS) нет места большинству принципов SOLID (да всем, кроме первого, наверное). Другое дело — TypeScript, который позволяет и поощряет программирование в ООП-стиле — и для него все эти принципы вполне актуальны.</p> <p>Рассмотрим набор шаблонов, который ощутимо меньше цепляется за ООП — GRASP.</p> <h2 id="grasp">GRASP</h2> <p>General responsibility assignment software patterns. Так этот GRASP расшифровывается. Общие шаблоны распределения ответственностей. Заметьте, и в SOLID многое было посвящено распределению ответственностей — заставляет задуматься, насколько это важно в разработке ПО. Ну да ладно.</p> <p>GRASP — это девять шаблонов распределения ответственностей. Давайте разберем их.</p> <ol> <li> <p>Information Expert (Информационный эксперт).</p> <p>Информационный эксперт — это штука, связанная с S в SOLID. Звучит описание шаблона примерно так: “Ответственность должна быть назначена тому, кто владеет максимумом информации для исполнения — информационному эксперту”. То есть, класс (или объект), владеющий максимумом информации о некой доменной области, должен отвечать и за исполнение задач этой доменной области. По сути, тот же принцип единственной ответственности.</p> </li> <li> <p>Creator (Создатель).</p> <p>Если вы слышали о паттерне проектирования “фабрика”/”абстрактная фабрика”, то это оно. Точнее, не совсем оно. Этот шаблон отвечает на вопрос “кто (какая фабрика) должен создавать объекты некоторого типа А?”. И отвечает он так: назначить объекту B создавать объекты А, если:</p> <ul> <li>содержит или агрегирует объекты A; <ul> <li>записывает объекты A;</li> <li>активно использует объекты A;</li> <li>обладает данными для создания объектов A;</li> </ul> </li> </ul> <p>Ну, то есть, ответственность за создание объектов A должна быть назначена тому, кто владеет максимумом информации для исполнения. Выходит, что по отношению к объектам A объект B — информационный эксперт.</p> </li> <li> <p>Controller (Контроллер).</p> <p>Та самая буква C в паттерне MVC. Штука, которая отвечает за прием запросов от пользователя и делегирование их исполнения соответствующим информационным экспертам.</p> </li> <li> <p>Low Coupling (Низкое связывание).</p> <p>Этот шаблон немного связан с буквой I в SOLID (да и с буквой S тоже). Речь о том, что объекты (классы) должны быть слабо связаны и как можно более независимы друг от друга в смысле внесения изменений (в идеале, во вполне достижимом идеале, полностью независимы).</p> </li> <li> <p>High Cohesion (Высокая связность).</p> <p>Тут речь о том, что обязанности данного элемента тесно связаны и сфокусированы. Разбиение программ на классы и подсистемы является примером деятельности, которая увеличивает связность системы.</p> </li> <li> <p>Polymorphism (Полиморфизм)</p> <p>Да, тот самый, из ООП. Реализуется в том числе паттернами “Адаптер” и “Стратегия”, и в целом говорит нам о том, что разные объекты могут наследоваться от одних и тех же интерфейсов, реализуя их методы по-разному. Помним о буковке I в SOLID.</p> </li> <li> <p>Pure Fabrication (Чистая выдумка).</p> <p>О чем здесь речь? Да практически о том, о чем и в шаблоне Creator. Стоит задача: создавать объекты A, не используя средства класса A. Решение: создать Creator (создать создателя, лол) для класса A.</p> </li> <li> <p>Redirection (Перенаправление).</p> <p>Хороший пример перенаправления — шаблон “Контроллер”, который становится посредником между моделью и представлением в паттерне MVC, таким образом реализуя шаблон Low Coupling, уменьшая связывание между классами.</p> </li> <li> <p>Устойчивость к изменениям (Protected Variations).</p> <p>И тут все тоже довольно просто: надо объектам взаимодействовать? Пусть взаимодействуют через специально для этого созданный интерфейс. Пример шаблона Redirection, тоже уменьшает связность.</p> </li> </ol> <h3 id="grasp-выводы">GRASP. Выводы</h3> <p>Оно вроде все тоже про ООП, да? Но понятия связности и ответственности есть в любой системе, и мы должны учитывать эти шаблоны при разработке в том числе на JS.</p> <h2 id="dry">DRY</h2> <p>Тут все просто: Don’t repeat yourself. Не надо копипастить код, это антипаттерн. Выносите несколько раз используемый код в методы. Только если это не нарушает SOLID и GRASP.</p> <h2 id="выводы">Выводы</h2> <p>ООП-принципы в большинстве своем применимы к JS и полностью применимы к TS. И учить их надо не только для прохождения собесов :)</p>]]></content><author><name></name></author><category term="theory"/><category term="theory"/><summary type="html"><![CDATA[Статья о шаблонах и принципах проектирования — больше об ООП, чуть меньше о JS.]]></summary></entry><entry><title type="html">Как работает HTTP: разбор в деталях</title><link href="https://sptmru.github.io/2023/http-in-details/" rel="alternate" type="text/html" title="Как работает HTTP: разбор в деталях"/><published>2023-02-06T22:20:43+04:00</published><updated>2023-02-06T22:20:43+04:00</updated><id>https://sptmru.github.io/2023/http-in-details</id><content type="html" xml:base="https://sptmru.github.io/2023/http-in-details/"><![CDATA[<h2 id="введение">Введение</h2> <p>Частый вопрос на собеседованиях у бэкенд-разработчиков (и, действительно, это важно знать): что такое HTTP и как он работает?</p> <p>Вот об этом мы сегодня и поговорим. Постараемся нырнуть достаточно глубоко, заодно задеть HTTPS и в целом сконцентрировать в этой статье все знания об HTTP, которые нужны любому бэкенд-разработчику.</p> <h2 id="что-такое-http">Что такое HTTP?</h2> <p>HTTP (HyperText Transfer Protocol, протокол передачи гипертекста) — это, как понятно из названия, протокол, то есть некая договоренность о том, как сервер и клиент взаимодействуют в контексте передачи гипертекста (это странное слово значит всего лишь текст с гиперссылками). Сейчас, впрочем, по HTTP передают далеко не только текст со ссылками (но и его тоже).</p> <p>Работает HTTP на прикладном уровне, и работает он поверх TCP (который, в свою очередь, работает на транспортном уровне. Когда-нибудь я напишу статью об уровнях модели OSI, но пока она даже не в бэклоге). По умолчанию HTTP использует порт 80/tcp, но может работать и на любом другом порту — все зависит от настроек сервера.</p> <p>Используем мы его очень часто, так как это основной протокол, по которому работает WWW. Когда ваш браузер открывает сайт, он делает это по HTTP (точнее, сначала по DNS, потом по HTTP, а потом (крайне вероятно) по HTTPS (который самостоятельным протоколом не является, это расширение протокола HTTP, и мы его в этой статье тоже затронем)).</p> <p>HTTP работает в рамках клиент-серверной архитектуры, то есть выглядит это примерно так:</p> <ul> <li>клиент (часто браузер) запрашивает у сервера некий ресурс</li> <li>сервер обрабатывает запрос и возвращает клиенту что-то (и это не всегда то, что просил клиент): возможно, это тот самый ресурс, может быть, что это указание, где этот ресурс на самом деле лежит, а может быть, и ошибка.</li> </ul> <p>Давайте чуть подробнее разберем обмен сообщениями между клиентом и сервером.</p> <h2 id="http-запросы-и-http-ответы">HTTP-запросы и HTTP-ответы</h2> <p>HTTP-сообщения бывают двух видов: это, как мы уже поняли, запросы и ответы. Клиент отправляет запрос — а сервер на него отвечает (всегда, если не рассматривать ситуации с проблемами с сетевым соединением, доступностью сервера и типа того).</p> <p>Как запросы, так и ответы выглядят примерно так:</p> <ol> <li>Стартовая строка — в ней содержится версия HTTP, которую мы используем, и другая информация — типа запрашиваемого ресурса или кода ответа.</li> <li>Заголовки HTTP (далее мы поговорим о них подробнее): несколько строчек текста в заранее оговоренном формате, которые как-то уточняют запрос или содержимое ответа.</li> <li>Пустая строка, которая означает, что все метаданные (версия протокола, заголовки — в общем, все, что было в первых двух пунктах) отправлены.</li> <li>Тело сообщения (которое существует не всегда) — к примеру, данные, связанные с запросом, или HTML-страница, переданная в ответе.</li> </ol> <p>Давайте смотреть на все пункты подробнее.</p> <h3 id="http-запрос">HTTP-запрос</h3> <h4 id="стартовая-строка-http-запроса">Стартовая строка HTTP-запроса</h4> <p>Стартовая строка HTTP-запроса выглядит как-то так:</p> <p><code class="language-plaintext highlighter-rouge">GET /index.html HTTP/1.1</code></p> <p>Первая часть (<code class="language-plaintext highlighter-rouge">GET</code>) — это метод запроса. Он говорит серверу, что мы вообще от него хотим. Вот список самых популярных HTTP-методов:</p> <ul> <li><code class="language-plaintext highlighter-rouge">GET</code> — запрашивает какой-то ресурс у сервера (в примере <code class="language-plaintext highlighter-rouge">/index.html</code>)</li> <li><code class="language-plaintext highlighter-rouge">HEAD</code> — это как <code class="language-plaintext highlighter-rouge">GET</code>, только сервер вернет исключительно заголовки, не сам ресурс. Используется, к примеру, для того, чтобы узнать размер ресурса перед его загрузкой</li> <li><code class="language-plaintext highlighter-rouge">POST</code> — позволяет отправить данные на сервер. Используется для создания чего-то, часто - для авторизации / аутентификации, загрузки данных на сервер (типа изображений или документов)</li> <li><code class="language-plaintext highlighter-rouge">PUT</code> / <code class="language-plaintext highlighter-rouge">PATCH</code> — позволяет изменить что-то, уже существующее на сервере</li> <li><code class="language-plaintext highlighter-rouge">DELETE</code> — что-то удаляет на сервере</li> <li><code class="language-plaintext highlighter-rouge">OPTIONS</code> — спрашивает информацию о сервере, в том числе список поддерживаемых сервером методов</li> </ul> <p>Вторая часть <code class="language-plaintext highlighter-rouge">/index.html</code> — это URI (Uniform Resource Identifier, унифицированный идентификатор ресурса) — это путь к ресурсу, который мы хотим загрузить / поменять / создать (в зависимости от метода и конфигурации сервера).</p> <p>Третья часть — версия HTTP, в соответствии с которой составлен запрос. В примере — 1.1. Вообще, сейчас гораздо более популярна версия <code class="language-plaintext highlighter-rouge">HTTP/2</code>, но сайты с <code class="language-plaintext highlighter-rouge">HTTP/1.1</code> вполне себе встречаются.</p> <h4 id="заголовки-http-запроса">Заголовки HTTP-запроса</h4> <p>Заголовки запроса этот самый запрос уточняют. Давайте перечислим самые популярные из них:</p> <ul> <li><code class="language-plaintext highlighter-rouge">Host</code> — единственный обязательный заголовок запроса. Содержит доменное имя или IP-адрес, к которому мы обращаемся. Для чего это нужно? В том числе для того, чтобы сервер понимал, к какому именно доменному имени / IP-адресу мы обращаемся — ведь на сервере может быть размещено несколько сайтов на разных IP-адресах или доменных именах (это называется “IP-Based Virtual Host” / “Name-Based Virtual Host”).</li> <li><code class="language-plaintext highlighter-rouge">User-Agent</code> — описывает клиент, который обращается к серверу.</li> <li><code class="language-plaintext highlighter-rouge">Refer</code> — содержит информацию о том, откуда поступил текущий запрос (к примеру, вы переходите с сайта <code class="language-plaintext highlighter-rouge">http://site1.com</code> по ссылке на сайт <code class="language-plaintext highlighter-rouge">http://site2.com</code> — тогда в заголовке <code class="language-plaintext highlighter-rouge">Refer</code>, вероятно, будет содержаться <code class="language-plaintext highlighter-rouge">http://site1.com</code>).</li> <li><code class="language-plaintext highlighter-rouge">Accept</code> — указывает, какие типы медиафайлов умеет принимать клиент.</li> <li><code class="language-plaintext highlighter-rouge">Cookie</code> — может содержать куки, предварительно отправленные на сервер или отправленные сервером (с помощью заголовка ответа <code class="language-plaintext highlighter-rouge">Set-Cookie</code>, который мы разберем позже).</li> <li><code class="language-plaintext highlighter-rouge">Authorization</code> — обычно работает так: после какого-то рода аутентификации клиента на сервере сервер возвращает некий токен, который клиент после отправляет в каждом запросе. Вот как раз в заголовке <code class="language-plaintext highlighter-rouge">Authorization</code> этот токен и отправляется.</li> </ul> <p>А вот <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers">здесь</a> можно почитать о других HTTP-заголовках.</p> <h4 id="тело-сообщения-http-запроса">Тело сообщения HTTP-запроса</h4> <p>HTTP-запрос завершается телом. Но далеко не у каждого запроса предполагается наличие тела: тело есть у запросов, что-то меняющих на сервере — то есть у запросов с методами <code class="language-plaintext highlighter-rouge">GET</code>, <code class="language-plaintext highlighter-rouge">HEAD</code>, <code class="language-plaintext highlighter-rouge">OPTIONS</code> наличие тела не предполагается (хотя никто не запрещает его передавать), а у запросов с методами <code class="language-plaintext highlighter-rouge">POST</code>, <code class="language-plaintext highlighter-rouge">PUT</code>, <code class="language-plaintext highlighter-rouge">PATCH</code> наличие тела предполагается (хотя его может не быть). Запросы <code class="language-plaintext highlighter-rouge">DELETE</code> обычно не имеют тела, потому что, хоть и что-то меняют на сервере, но не добавляют никаких новых данных. Но, опять же, и у таких запросов может быть тело.</p> <h3 id="http-ответ">HTTP-ответ</h3> <p>Как мы определили ранее, если с сетью и сервером все в порядке, каждый HTTP-запрос получит ответ. Давайте разберемся, из чего обычно состоят HTTP-ответы.</p> <h4 id="стартовая-строка-строка-статуса-http-ответа">Стартовая строка (строка статуса) HTTP-ответа</h4> <p>Стартовая строка (которую еще называют строкой статуса) HTTP-ответа может выглядеть, к примеру, так:</p> <p><code class="language-plaintext highlighter-rouge">HTTP 1/1 200 OK</code></p> <p>Здесь первая часть (<code class="language-plaintext highlighter-rouge">HTTP 1/1</code>) — это знакомая нам по стартовой строке HTTP-запроса версия HTTP-протокола. Вторая часть (<code class="language-plaintext highlighter-rouge">200</code> в примере) — это код состояния, а третья (<code class="language-plaintext highlighter-rouge">OK</code>) — его текстовое описание. Коды состояния мы разберем подробнее. Итак, коды состояния бывают такие:</p> <ul> <li><code class="language-plaintext highlighter-rouge">1xx</code> — коды, начинающиеся с единицы, никак не влияют на обработку запроса и просто передают информацию. Например, код <code class="language-plaintext highlighter-rouge">101 Switching Protocols</code> сообщает клиенту о смене протокола. Вот такой вот ответ говорит клиенту, что сервер переходит с HTTP на WebSockets:</li> </ul> <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">101</span> <span class="ne">Switching Protocols</span>
<span class="na">Upgrade</span><span class="p">:</span> <span class="s">websocket</span>
<span class="na">Connection</span><span class="p">:</span> <span class="s">Upgrade</span>
</code></pre></div></div> <ul> <li> <p><code class="language-plaintext highlighter-rouge">2xx</code> — коды, начинающиеся с двойки, возвращаются тогда, когда клиентский запрос был успешно обработан. Например, код <code class="language-plaintext highlighter-rouge">200 OK</code> вернется вместе с запрошенным ресурсом, а <code class="language-plaintext highlighter-rouge">201 Created</code> вернется, когда что-то успешно создано на сервере.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">3xx</code> — коды, начинающиеся с тройки, возвращаются, когда серверу нужно куда-то перенаправить клиента. Например, код <code class="language-plaintext highlighter-rouge">301 Moved Permanently</code> означает, что запрошенный ресурс теперь доступен по новому URI (который передается в заголовке <code class="language-plaintext highlighter-rouge">Location</code>).</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">4xx</code> — коды, которые начинаются с четверки, означают, что клиент отправил некорректный запрос. Например, код <code class="language-plaintext highlighter-rouge">403 Forbidden</code> означает, что у клиента нет доступа к запрошенному ресурсу, а всем известный <code class="language-plaintext highlighter-rouge">404 Not Found</code> означает, что запрошенный ресурс не найден.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">5xx</code> — коды, начинающиеся с пятерки, означают ошибку на сервере. К примеру, код <code class="language-plaintext highlighter-rouge">504 Gateway Timeout</code> говорит клиенту о том, что сервер, выполняя роль прокси, не дождался ответа от апстрима вовремя.</p> </li> </ul> <p>О всех возможных кодах состояния можно почитать <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">здесь</a>.</p> <h4 id="заголовки-http-ответа">Заголовки HTTP-ответа</h4> <p>Заголовки ответа используются для того, чтобы этот самый ответ уточнить, и не влияют на тело ответа. Заголовки HTTP-ответа выглядят абсолютно так же, как заголовки запроса.</p> <p>Вот примеры часто встречающихся заголовков ответа:</p> <ul> <li><code class="language-plaintext highlighter-rouge">Server</code> — содержит информацию о сервере. Пример: <code class="language-plaintext highlighter-rouge">Server: nginx</code>.</li> <li><code class="language-plaintext highlighter-rouge">Set-Cookie</code> — мы уже упоминали этот заголовок ранее. Он устанавливает куки, которые клиент затем сохраняет у себя. Пример: <code class="language-plaintext highlighter-rouge">Set-Cookie:PHPSSID=bf42938f</code>.</li> <li><code class="language-plaintext highlighter-rouge">WWW-Authenticate</code> — говорит клиенту, какой тип аутентификации используется для доступа к запрашиваемому ресурсу. Например: <code class="language-plaintext highlighter-rouge">WWW-Authenticate: BASIC realm=»localhost»</code>.</li> </ul> <h4 id="тело-ответа">Тело ответа</h4> <p>Обычно тело ответа присутствует, но иногда вся необходимая информация содержится в заголовке (типа <code class="language-plaintext highlighter-rouge">201 Created</code> или <code class="language-plaintext highlighter-rouge">204 No Content</code>), и тела у ответа тогда нет.</p> <h2 id="http2">HTTP/2</h2> <p>Для того, чтобы ответить на вопрос, зачем создавался HTTP/2 и в чем его основное преимущество, мы начнем с протокола <code class="language-plaintext highlighter-rouge">SPDY</code>, разработанного в Google как замена некоторых частей HTTP — в частности, по задумке разработчиков, вместо отдельного соединения для каждого ресурса используется мультиплексирование — таким образом, для передачи нескольких файлов теперь требовалось только одно соединение, что значительно ускоряло работу сайта. В 2011-2012 годов этот протокол поддерживался большинством браузеров и активно использовался в вебе.</p> <p>В 2015 году Рабочая группа HTTP IETF (Инженерного Совета Интернета) пересмотрела протокол HTTP и разработала версию протокола HTTP/2, которая в том числе включала мультиплексирование. В мае того же года протокол HTTP/2 был официально стандартизирован.</p> <h3 id="особенности-http2">Особенности HTTP/2</h3> <ul> <li>мультиплексированные потоки</li> </ul> <p>В отличие от модели “запрос-ответ”, используемой в HTTP/1.1, в HTTP/2 используются мультиплексированные потоки — данные в обе стороны передаются в рамках одного TCP-соединения в бинарном формате. Такой подход дает кучу преимуществ:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    - параллельные мультиплексированные запросы и ответы не блокируют друг друга
    - несмотря на передачу кучи данных, для наибольшей эффективности работы сети используется одно TCP-соединение
    - сервер может отправлять данные по своей инициативе (Server Push)
    - клиент может приоритезировать потоки, отдавая предпочтение конкретным потокам данных
    - заголовки сжимаются с помощью алгоритма HPACK
</code></pre></div></div> <p>Таким образом, HTTP/2 ощутимо быстрее HTTP/1.1. И да, на текущий момент гораздо популярнее. Кстати, переходя к следующей главе: HTTP/2 требует использования HTTPS.</p> <h2 id="https">HTTPS</h2> <p>HTTP имеет один фатальный недостаток: все данные передаются в открытом виде, что означает, что все данные, которыми клиент и сервер обмениваются друг с другом, можно перехватить. Это делает практически невозможным работу сервисов, которые обмениваются какими-то важными данными — типа банковских приложений, интернет-магазинов, каких-то государственных сервисов — в общем, всех сервисов, перехват данных для которых несет негативные последствия.</p> <p>Поэтому еще в 1994 году было разработано расширение протокола HTTP — HTTP Secure, или HTTPS. HTTPS, в отличие от HTTP, использует порт 443/tcp по умолчанию. До 2015 года он использовал протокол шифрования SSL, теперь же он использует TLS, но суть не поменялась.</p> <p>HTTPS работает благодаря TLS/SSL-сертификату. Этот сертификат можно назвать некой цифровой подписью сайта, с его помощью подтверждается подлинность сайта. Перед тем, как установить защищенное соединение, клиент запрашивает этот сертификат и обращается к центру сертификации, который этот сертификат выпустил, чтобы подтвердить легальность сертификата. Если сертификат действителен, клиент считает сайт безопасным и начинает обмен данными.</p> <p>Кроме подтверждения подлинности сайта, сертификат шифрует данные. После определения подлинности сайта начинается обмен шифрами. Шифрование HTTPS происходит с помощью асимметричного и симметричного ключа. Давайте рассмотрим их подробнее.</p> <h3 id="асимметричный-ключ">Асимметричный ключ</h3> <p>Каждая сторона имеет два ключа: публичный и приватный. Публичный ключ доступен любому, приватный — только владельцу. Когда клиент хочет отправить сообщение, он находит публичный ключ сервера, шифрует им сообщение, создавая секретный ключ, и отправляет серверу. Сервер расшифровывает полученное сообщение своим приватным ключом и делает то же самое: достает публичный ключ клиента, шифрует им сообщение, отправляет клиенту, клиент расшифровывает его своим приватным ключом. Теперь у каждой из сторон есть одинаковый секретный ключ.</p> <h3 id="симметричный-ключ">Симметричный ключ</h3> <p>Когда клиент и сервер установили первичное соединение и создали секретный ключ, они используют его для шифрования всех данных, которые передают друг другу. Так как ключ не надо создавать заново каждый раз, симметричный ключ быстрее.</p> <h2 id="в-завершение">В завершение</h2> <p>Вот <a href="https://developer.mozilla.org/en-US/docs/">здесь</a> есть вся документация по HTTP. По сравнению с ней, эта статья — просто ознакомительная :)</p> <p>Завершить хотелось бы тем, что HTTP и сам используется как транспорт — для таких протоколов, как SOAP, XML-RPC, WebDAV. REST, опять же, использует HTTP как транспорт. Мы можем считать HTTP как минимум одним из главных протоколов интернета.</p>]]></content><author><name></name></author><category term="theory"/><category term="theory"/><summary type="html"><![CDATA[Статья об HTTP, HTTP/2, HTTPS и вот этом всем]]></summary></entry><entry><title type="html">Асинхронность в JavaScript: практика и теория</title><link href="https://sptmru.github.io/2023/asynchrony-in-js/" rel="alternate" type="text/html" title="Асинхронность в JavaScript: практика и теория"/><published>2023-02-03T15:31:43+04:00</published><updated>2023-02-03T15:31:43+04:00</updated><id>https://sptmru.github.io/2023/asynchrony-in-js</id><content type="html" xml:base="https://sptmru.github.io/2023/asynchrony-in-js/"><![CDATA[<p>Достаточно важная как для браузерного JS, так и для Node.js (на котором мы остановимся подробнее) тема — асинхронность. Все мы слышали и знаем, что JavaScript — язык асинхронный, и все мы знаем, что он еще и однопоточный.</p> <p>Если чуть задуматься об этом, становится непонятно: а как такое в принципе возможно? Если у нас есть только один поток, то что произойдет, если мы выполним в нем блокирующую операцию — например, обратимся к файловой системе или базе данных? Разве может успешно существовать язык программирования, с программами на котором может одновременно работать только один процесс?</p> <p>Конечно, в JS это решено, и решено довольно интересно. И, как и все интересные штуки, эта штука достаточно сложна. Поэтому эта статья — статья-перевертыш: мы начнем с того, как на практике работать с асинхронными задачами, а уже потом разберем, что там под капотом происходит.</p> <h2 id="практика">Практика</h2> <h3 id="callbacks">Callbacks</h3> <p>Итак, для начала вернемся во времена до выхода ES6, существенно прокачавшего JS. Тогда, в эти прекрасные дни, асинхронные штуки мы делали примерно так:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">blockingFunc</span> <span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// do blocking things</span>
  <span class="nx">callback</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">logDone</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Done</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">blockingFunc</span><span class="p">(</span><span class="nx">logDone</span><span class="p">);</span>
</code></pre></div></div> <p>Что здесь происходит? У нас есть некая функция <code class="language-plaintext highlighter-rouge">blockingFunc()</code>, которая делает нечто, блокирующее наш поток, а потом выполняет некую функцию <code class="language-plaintext highlighter-rouge">callback()</code>, которую она принимает аргументом (да, в JavaScript мы можем передать в функцию аргументом другую функцию. Это называется «функции первого класса». На самом деле, мы можем даже передать в функцию целый класс, и получится у нас класс первого класса. Но это уже другая тема).</p> <p>В чем проблема такого подхода к написанию кода? А в том, что называли «callback hell». Мы выполняем функцию, в которую передаем функцию-коллбек, в которую передавали свою функцию-коллбек…и очень скоро это превращалось во что-то не очень читаемое. Смотрите:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">getBeef</span><span class="p">(</span><span class="dl">'</span><span class="s1">John</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">rawBeef</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">sliceBeef</span><span class="p">(</span><span class="nx">rawBeef</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">slicedBeef</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">cookBeef</span><span class="p">(</span><span class="nx">slicedBeef</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">cookedBeef</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">serveBeef</span><span class="p">(</span><span class="nx">cookedBeef</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">servedBeef</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">servedBeef</span><span class="p">)</span>
      <span class="p">})</span>
    <span class="p">})</span>
  <span class="p">})</span>
<span class="p">})</span>
</code></pre></div></div> <p>Видите проблему такого подхода? Мне кажется даже, что здесь я запутался в коллбеках :) а читать такое попросту мучительно.</p> <h3 id="promises">Promises</h3> <p>К счастью, вместе с ES6 к нам пришли промисы (Promise) и async/await. Что это такое и как это использовать, рассмотрим ниже.</p> <p>Promise — это под капотом те же коллбеки, но использовать и читать их гораздо приятнее. Давайте перепишем код выше с использованием промисов. Представим, что функция <code class="language-plaintext highlighter-rouge">getBeef()</code> выглядит примерно так: (небольшое отступление: в ней я использовал еще одну фичу ES6 — стрелочные функции, о них можно прочитать у меня <a href="https://github.com/sptmlearningjs/execution-context-in-js">здесь</a>:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">getBeef</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">beefExists</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">beef</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="nx">resolve</span><span class="p">(</span><span class="nx">beef</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">reject</span><span class="p">(</span><span class="dl">'</span><span class="s1">No beef available</span><span class="dl">'</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">},</span> <span class="mi">300</span><span class="p">)</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div> <p>Что происходит здесь? Функция <code class="language-plaintext highlighter-rouge">getBeef(name)</code> принимает имя человека, для которого мы в итоге будем готовить мясо и возвращает объект Promise.</p> <p>Promise, как написано в документации, это такой прокси-объект для значения, которое не обязательно известно, когда промис создается. В нашем случае мы не знаем, есть ли у нас мясо, когда создаем промис, и для проверки нам нужно немного времени. Мы не хотим ждать, блокируя основной поток, поэтому проверяем это асинхронно.</p> <p>Promise находится в одном из трех состояний:</p> <ul> <li>pending: изначальное состояние созданного промиса</li> <li>fulfilled: означает, что операция выполнена успешно</li> <li>rejected: означает, что операция провалена</li> </ul> <p>Мы считаем промис выполненным (settled), если он либо выполнен успешно (fulfilled), либо провален (rejected), но не находится в ожидании (pending). Часто говорят, что промис зарезолвился (resolved), когда он выполнен.</p> <p>Когда мы создаем промис, мы устанавливаем значения, которые он вернет в случае, когда он выполнен успешно (с помощью функции <code class="language-plaintext highlighter-rouge">resolve()</code>) и когда он провален (с помощью <code class="language-plaintext highlighter-rouge">reject()</code>). В нашем случае, если промис выполнен успешно (условная переменная <code class="language-plaintext highlighter-rouge">beefExists === true</code>), мы вернем <code class="language-plaintext highlighter-rouge">beef</code> (то самое мясо), а если промис провален, мы вернем сообщение, что мяса, к сожалению, нет.</p> <p>У Promise есть три метода: <code class="language-plaintext highlighter-rouge">then()</code>, <code class="language-plaintext highlighter-rouge">catch()</code>, <code class="language-plaintext highlighter-rouge">finally()</code>. <code class="language-plaintext highlighter-rouge">then()</code> принимает два аргумента: первый — это коллбек, выполняющийся, когда промис успешно зарезолвился, второй — коллбек, который выполнится, если промис провалится. Често второй аргумент опускают, ведь есть <code class="language-plaintext highlighter-rouge">catch()</code>, который принимает один аргумент — коллбек, который выполнится, если промис провалится. <code class="language-plaintext highlighter-rouge">finally()</code> тоже принимает один аргумент, который выполнится, когда промис зарезолвится любым образом: провалится ли — или же успешно выполнится.</p> <p>Все эти методы возвращают новый Promise, что очень удобно, ведь их можно связывать в цепочки (chaining). Теперь давайте перепишем весь наш код на коллбеках с использованием промисов:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">getBeef</span><span class="p">(</span><span class="dl">'</span><span class="s1">John</span><span class="dl">'</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">sliceBeef</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">cookBeef</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">serveBeef</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">servedBeef</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">servedBeef</span> <span class="p">?</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Beef is served!</span><span class="dl">'</span><span class="p">):</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Beef is not served</span><span class="dl">'</span><span class="p">))</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">err</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">));</span>

</code></pre></div></div> <p>Гораздо более читабельно, правда?</p> <p>Есть еще два интересных метода, связанных с промисами: <code class="language-plaintext highlighter-rouge">Promise.all()</code> и <code class="language-plaintext highlighter-rouge">Promise.allSettled()</code>. Оба позволяют комбинировать промисы, получая из них новый, но <code class="language-plaintext highlighter-rouge">Promise.all()</code> будет считаться fulfilled только тогда, когда все переданные в него промисы будут fulfilled. Для <code class="language-plaintext highlighter-rouge">Promise.allSettled()</code> же, чтобы считаться fulfilled, достаточно, чтобы все промисы, в него переданные, не были pending (то есть все промисы должны как-то отрезолвиться, fulfilled или rejected — без разницы). Давайте посмотрим на примере:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">promise1</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span> <span class="c1">// fulfilled promise</span>
<span class="kd">const</span> <span class="nx">promise2</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span> <span class="c1">// also fulfilled promise</span>
<span class="kd">const</span> <span class="nx">promise3</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span> <span class="c1">// rejected promise</span>
<span class="kd">const</span> <span class="nx">promise4</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{});</span> <span class="c1">// pending promise</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">promise1</span><span class="p">,</span> <span class="nx">promise2</span><span class="p">])</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">fulfilled!</span><span class="dl">'</span><span class="p">))</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">rejected!</span><span class="dl">'</span><span class="p">));</span> <span class="c1">// fulfilled! (as all promises are fulfilled)</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">promise1</span><span class="p">,</span> <span class="nx">promise2</span><span class="p">,</span> <span class="nx">promise3</span><span class="p">])</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">fulfilled!</span><span class="dl">'</span><span class="p">))</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">rejected!</span><span class="dl">'</span><span class="p">));</span> <span class="c1">// rejected! (as promise3 is rejected)</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span><span class="nx">promise1</span><span class="p">,</span> <span class="nx">promise2</span><span class="p">,</span> <span class="nx">promise4</span><span class="p">])</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">fulfilled!</span><span class="dl">'</span><span class="p">))</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">rejected!</span><span class="dl">'</span><span class="p">));</span> 
  <span class="c1">// nothing, Promise.all is still pending (for Promise.all to be resolved, all promises passed into it should be resolved)</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">allSettled</span><span class="p">([</span><span class="nx">promise1</span><span class="p">,</span> <span class="nx">promise2</span><span class="p">,</span> <span class="nx">promise3</span><span class="p">])</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">fulfilled!</span><span class="dl">'</span><span class="p">))</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">rejected!</span><span class="dl">'</span><span class="p">));</span> <span class="c1">// fulfilled! (as all promises are resolved)</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">allSettled</span><span class="p">([</span><span class="nx">promise1</span><span class="p">,</span> <span class="nx">promise2</span><span class="p">,</span> <span class="nx">promise4</span><span class="p">])</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">fulfilled!</span><span class="dl">'</span><span class="p">))</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">rejected!</span><span class="dl">'</span><span class="p">));</span> 
  <span class="c1">// nothing, Promise.allSettled is still pending (for Promise.allSettled to be resolved, all promises passed into it should be resolved)</span>
</code></pre></div></div> <p>Есть еще один прикольный метод, связанный с промисами — <code class="language-plaintext highlighter-rouge">Promise.race()</code>. Он похож на предыдущие два, разница лишь в том, что резолвится <code class="language-plaintext highlighter-rouge">Promise.race()</code> тогда, когда резолвится хотя бы один из переданных в него промисов. Глянем на примере:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">promise1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="dl">'</span><span class="s1">one</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>

<span class="kd">const</span> <span class="nx">promise2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">((</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="dl">'</span><span class="s1">two</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">race</span><span class="p">([</span><span class="nx">promise1</span><span class="p">,</span> <span class="nx">promise2</span><span class="p">]).</span><span class="nx">then</span><span class="p">((</span><span class="nx">value</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
  <span class="c1">// Both resolve, but promise2 is faster</span>
<span class="p">});</span>
<span class="c1">// Expected output: "two"</span>
</code></pre></div></div> <h3 id="async--await">Async / Await</h3> <p>Итак, с промисами разобрались. Учитывая следующую тему, которую мы в этой статье разберем, стоит сказать: промисы — это не какая-то около-deprecated-штука, это вполне себе актуальная и часто используемая функциональность JS, и она никуда не пропадет. Почему я это говорю?</p> <p>А потому что в JS можно писать асинхронный код, который буквально выглядит как синхронный: для этого в ES6 вместе с промисами подъехал синтаксический сахар над ними — <code class="language-plaintext highlighter-rouge">async</code> и <code class="language-plaintext highlighter-rouge">await</code>. Давайте воспользуемся предыдущим опытом и перепишем код, что мы писали выше, с использованием <code class="language-plaintext highlighter-rouge">async/await</code>:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">beef</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">getBeef</span><span class="p">(</span><span class="dl">'</span><span class="s1">John</span><span class="dl">'</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">slicedBeef</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">sliceBeef</span><span class="p">(</span><span class="nx">beef</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">cookedBeef</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">cookBeef</span><span class="p">(</span><span class="nx">slicedBeef</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">servedBeef</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">serveBeef</span><span class="p">(</span><span class="nx">cookedBeef</span><span class="p">);</span>
    
    <span class="nx">servedBeef</span> <span class="p">?</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Beef is served!</span><span class="dl">'</span><span class="p">)</span> <span class="p">:</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Beef is not served!</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Стало еще более читабельно, правда? Но здесь нет ничего нового — это всего лишь синтаксический сахар (хотя, конечно, очень приятный) над промисами (которые, в свою очередь, просто синтаксический сахар над коллбеками. Но какая разница? Удобнее стало? Стало. Вот и отлично.)</p> <h2 id="теория">Теория</h2> <p>Что ж, с практикой мы вроде как разобрались. Пора закопаться поглубже и разобраться, как оно все работает. А работает оно довольно интересно.</p> <p>Давайте для начала разберемся, из чего состоит Node.js.</p> <h3 id="компоненты-nodejs">Компоненты Node.js</h3> <h4 id="v8">V8</h4> <p>Cобственно, движок, который компилирует и выполняет JavaScript-код, занимается выделением памяти под объекты и включает в себя сборщик мусора, который освобождает память, занимаемую объектом, когда ссылок на объект уже нет и он уже не нужен.</p> <p>Раньше V8 занимался JIT-компиляцией всегда, теперь же (с версии 7.4) у него появилась опция <code class="language-plaintext highlighter-rouge">—jitless</code>, в этом режиме он работает исключительно как интерпретатор. Это полезно, когда мы не можем аллоцировать память в рантайме (к примеру, в iOS, некоторых смарт-TV и прочем таком). Нам, как бэкенд-разработчикам, знать такое не обязательно, но разве же знания бывают лишними?</p> <p>Итак, V8. Компилирует и выполняет JS-код, работает со стеком, управляет выделением памяти и сборкой мусора, а также обеспечивает нас всеми типами данных, операторами, объектами и функциями.</p> <h4 id="libuv">libuv</h4> <p>К сожалению, V8 не может работать с операционными системами напрямую — это было бы сложно поддерживать (к примеру, у *nix-систем есть проблемы с поддержкой non-blocking I/O-операций, и работа с ними напрямую была бы как минимум крайне нетривиальной задачей). Поэтому приходится использовать библиотеку-посредник между V8 и ОС — собственно, libuv и используется. Удобно, что есть один мультиплатформенный инструмент, реализующий асинхронный ввод-вывод — без такого инструмента существование Node.js было бы попросту невозможно.</p> <h4 id="c---аддоны">C++ - аддоны</h4> <p>Да, для Node.js написано множество аддонов на C++. С помощью них, например, реализованы воркеры, и мы можем в дополнение к основному потоку выполнение разворачивать дополнительные дочерние треды.</p> <h4 id="nodejs---биндинги">Node.js - биндинги</h4> <p>Для того, чтобы связываться и работать с какими-то внешними штуками, Node.js нужны биндинги — по сути, это библиотеки, которые позволяют нам использовать библиотеки, написанные на других языках, вместе с Node.js. Это нужно, к примеру, для разного рода I/O: соединение с базами данных, файловыми системами и прочими такими штуками.</p> <h3 id="event-loop">Event Loop</h3> <p>И вот теперь, наконец, мы подошли к главному, к тому, ради чего эта статья и затевалась — к возможности ответить на вопрос, как же все-таки Node.js выполняет неблокирующие (асинхронные операции ввода-вывода, несмотря на то, что он однопоточный — оказывается, он с помощью libuv отдает множество работы операционной системе.</p> <p>Учитывая то, что большинство современных ядер ОС многопоточны, они могут выполнять множество операций одновременно в фоне. Когда какая-то из этих операций завершается, ядро операционной системы дает об этом знать Node.js, чтобы соответствующий коллбек мог быть добавлен в poll-очередь (мы объясним, что это, чуть позже), чтобы со временем быть выполненным.</p> <p>Итак, когда Node.js запускается, он запускает event loop и исполняет входящий скрипт, который может выполнять асинхронные запросы к API, планировать таймеры или вызывать <code class="language-plaintext highlighter-rouge">process.nextTick()</code>, после чего начинает исполнять цикл событий (собственно, event loop).</p> <p>Давайте для начала вкратце определимся, как примерно работает event loop, что такое микротаски и макротаски, а затем разберем фазы event loop.</p> <h4 id="микротаски-и-макротаски">Микротаски и макротаски</h4> <p>Помимо обычных синхронных задач, в JS существуют так называемые микротаски и макротаски.</p> <p>Микротаски имеют приоритет над макротасками, и, пока выполняются задачи из очереди микротасок, до макротасок дело не дойдет. Микротаски — это промисы, то, что запланировано с помощью <code class="language-plaintext highlighter-rouge">process.nextTick()</code> и <code class="language-plaintext highlighter-rouge">queueMicrotack()</code>, в браузере — еще и результат работы <code class="language-plaintext highlighter-rouge">MutationObserver</code> (вкратце — такая штука, генерящая уведомления об изменении определенных DOM-элементов). Макротаски — это то, что выполняется только тогда, когда очередь микротасок пуста. Это то, что мы планируем с помощью <code class="language-plaintext highlighter-rouge">setTimeout()</code>, <code class="language-plaintext highlighter-rouge">setImmediate()</code>, <code class="language-plaintext highlighter-rouge">setInterval()</code>, в браузере — еще и рендеринг. С учетом того, что микротаски блокируют выполнение макротасок, напрашивается очевидный вывод — не стоит забивать очередь микротасок, иначе мы заблокируем все макротаски.</p> <p>Если вкратце, event loop работает так: выполняет микротаски, пока они есть, ставя себя на паузу, затем продолжается, исполняет макротаску и возвращается к микротаскам.</p> <h4 id="фазы-event-loop">Фазы Event Loop</h4> <p>Для начала — коротко перечислим все эти фазы и объясним, что в них происходит, после чего перейдем к деталям.</p> <ul> <li>timers - в этой фазе исполняются коллбеки, запланированные с помощью <code class="language-plaintext highlighter-rouge">setTimeout()</code> и <code class="language-plaintext highlighter-rouge">setInterval()</code></li> <li>pending callbacks - выполняются коллбеки ввода/вывода, отложенные до следующей итерации цикла событий</li> <li>idle, prepare - используются исключительно для внутренних нужд</li> <li>poll - получаются новые события ввода/вывода, выполняются связанные с вводом/выводом коллбеки (почти все, за исключением тех, которые запланированы таймерами и <code class="language-plaintext highlighter-rouge">setImmediate()</code>). Поток будет блокироваться здесь, когда это уместно. Тут мы как раз работаем с очередью микротасок.</li> <li>check - <code class="language-plaintext highlighter-rouge">setImmediate()</code> - коллбеки вызываются здесь</li> <li>close callbacks - закрываются некоторые коллбеки типа socket.on(‘close’, …)</li> </ul> <p>Между каждым запуском цикла событий, Node.js проверяет, не ожидает ли он каких-то асинхронных операций ввода-вывода, таймеров и останавливается без ошибок, если ничего не ожидается.</p> <p>Давайте разбирать эти фазы чуть подробнее.</p> <h4 id="timers">timers</h4> <p>Таймер указывает некий порог времени, после которого коллбек может быть выполнен, это не точное время, через которое коллбек точно выполнится. Коллбеки таймеров будут запущены так рано, как могут, после того, как указанное в таймере время пройдет — однако, планирование ОС или выполнение других коллбеков может отложить их выполнение.</p> <p>На самом деле, фаза poll контролирует, когда таймеры выполняются. К примеру, скажем, вы запланировали таймаут так, чтобы он выполнился после задержки в 100 мс, а потом ваш скрипт начинает асинхронно читать файл, что занимает 95 мс. Когда event loop входит в фазу poll, его очередь пуста (<code class="language-plaintext highlighter-rouge">fs.readFile()</code>еще не выполнена), так что он подождет то количество миллисекунд, которого хватит для выполнения ближайшего по времени таймера. Пока event loop ждет 95 миллисекунд, <code class="language-plaintext highlighter-rouge">fs.readFile()</code> заканчивает читать файл, и его коллбек, которому требуется 10 мс для выполнения добавляется в очередь poll и выполняется. Когда он заканчивает выполнение, в очереди больше нет коллбеков, поэтому event loop увидит, что порог ближайшего таймера достигнут, и вернется к фазе таймеров, чтобы выполнить коллбек таймера. Таким образом, в этом примере общая задержка между планированием таймера и выполнением его коллбека составит 105 мс.</p> <p>Чтобы перебор микротасок не приводил к тому, чтобы в event loop ничего не поступало, библиотека <code class="language-plaintext highlighter-rouge">libuv</code> тоже имеет зависимое от ОС ограничение максимального количества ивентов, прежде чем она прекратит запрашивать новые события.</p> <h4 id="pending-callbacks">pending callbacks</h4> <p>На этом этапе выполняются коллбеки для разного рода системных операций. К примеру, если TCP-сокет получает ошибку <code class="language-plaintext highlighter-rouge">ECONNREFUSED</code> (в соединении отказано), некоторые *nix-системы захотят подождать перед тем, как сообщить об ошибке. Это и уйдет в очередь, чтобы выполниться в фазе pending callbacks.</p> <h4 id="poll">poll</h4> <p>Фаза poll имеет два основных назначения:</p> <ul> <li>вычислить, сколько I/O будет блокировать поток</li> <li>обработать события в poll queue</li> </ul> <p>Когда event loop переходит в фазу poll и нет ни одного запланированного таймера, случится что-то из этого:</p> <ul> <li>если очередь микротасок не пуста, event loop пройдется по очереди микротасок, выполняя их синхронно до тех пор, пока либо очередь не опустеет, либо не будет достигнут тот самый лимит на максимальное количество ивентов в libuv</li> <li>если же очередь микротасок пуста, произойдет еще одно из двух событий: <ul> <li>если что-то было запланировано с помощью <code class="language-plaintext highlighter-rouge">setImmediate()</code>, event loop закончит poll-фазу и выполнит то, что было запланировано</li> <li>если ничего не было запланировано с помощью <code class="language-plaintext highlighter-rouge">setImmediate()</code>, event loop подождет, пока коллбеки добавятся в очередь, и немедленно их выполнит</li> </ul> </li> </ul> <p>Как только очередь микротасок опустеет, event loop проверит наличие таймеров, пороговые значения которых был достигнуты. Если один или несколько таймеров доступны, event loop вернется к фазе timers и выполнит коллбеки этих таймеров.</p> <h4 id="check">check</h4> <p>Фаза check позволяет исполнять коллбеки сразу же после того, как фаза poll завершена. Если фаза poll простаивает, и что-то запланировано с помощью <code class="language-plaintext highlighter-rouge">setImmediate()</code>, event loop может продолжиться до фазы check вместо того, чтобы ждать.</p> <p>На самом деле, <code class="language-plaintext highlighter-rouge">setImmediate()</code> — это такой специальный таймер, который запускается в отдельной фазе event loop. Он использует API <code class="language-plaintext highlighter-rouge">libuv</code>, чтобы планировать коллбеки к выполнению после завершения poll-фазы.</p> <p>Как правило, по мере выполнения event loop в итоге переходит к фазе poll, где он будет ожидать входящего соединения, запроса или чего-то вроде того. Впрочем, если коллбек был запланирован с помощью <code class="language-plaintext highlighter-rouge">setImmediate()</code>, а фаза poll бездействует, она завершится и перейдет к фазе check вместо того≤ чтобы ждать poll-событий.</p> <h4 id="close-callbacks">close callbacks</h4> <p>Если сокет или дескриптор внезапно закроются, ивент ‘close’ будет сгенерирован на этом этапе. Иначе он будет отправлен через <code class="language-plaintext highlighter-rouge">process.nextTick()</code>.</p> <h4 id="setimmediate-vs-settimeout">setImmediate() vs setTimeout()</h4> <p><code class="language-plaintext highlighter-rouge">setImmediate()</code> и <code class="language-plaintext highlighter-rouge">setTimeout()</code> очень похожи, но ведут себя немного по-разному в зависимости от того, когда они вызваны.</p> <ul> <li><code class="language-plaintext highlighter-rouge">setImmediate()</code> выполнит то, что запланировано, как только текущая poll-фаза будет завершена</li> <li><code class="language-plaintext highlighter-rouge">setTimeout</code> выполнит запланированное после того, как минимальная указанная задержка в миллисекундах истечет</li> </ul> <p>Порядок, в котором выполняются таймеры, зависит от контекста, в котором они вызываются. Если оба вызываются из основного модуля, то время будет зависеть от производительности процесса.</p> <p>Например, если мы запустим вот этот скрипт, который не находится в I/O-цикле (то есть, в основном модуле) , порядок, в котором они выполнятся, неопределен, поскольку связан с производительностью процесса:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// timeout_vs_immediate.js</span>
<span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">timeout</span><span class="dl">'</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">0</span><span class="p">);</span>

<span class="nx">setImmediate</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">immediate</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>node timeout_vs_immediate.js
<span class="nb">timeout
</span>immediate

<span class="nv">$ </span>node timeout_vs_immediate.js
immediate
<span class="nb">timeout</span>
</code></pre></div></div> <p>Однако, если мы эти вызовы закинем в цикл I/O, коллбек <code class="language-plaintext highlighter-rouge">setImmediate()</code> всегда выполнится первым:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// timeout_vs_immediate.js</span>
<span class="kd">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">fs</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="nx">__filename</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">timeout</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">},</span> <span class="mi">0</span><span class="p">);</span>
  <span class="nx">setImmediate</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">immediate</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">});</span>
</code></pre></div></div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>node timeout_vs_immediate.js
immediate
<span class="nb">timeout</span>

<span class="nv">$ </span>node timeout_vs_immediate.js
immediate
<span class="nb">timeout</span>
</code></pre></div></div> <p>Главное преимущество <code class="language-plaintext highlighter-rouge">setImmediate()</code> — это то, что оно всегда будет выполнено перед всеми таймерами внутри I/O-цикла, вне зависимости от того, как много таймеров существует.</p> <h4 id="processnexttick-vs-setimmmediate">process.nextTick() vs setImmmediate()</h4> <p>У нас есть две штуки, похожие друг на друга, но их названия могут нас путать.</p> <p><code class="language-plaintext highlighter-rouge">process.nextTick()</code> срабатывает сразу же на тоей же фазе event loop. <code class="language-plaintext highlighter-rouge">setImmediate()</code> срабатывает на следующей итерации / “тике” event loop. Выглядит так, что имена функций нужно обменять местами.</p> <p><code class="language-plaintext highlighter-rouge">process.nextTick()</code> срабатывает быстрее, чем <code class="language-plaintext highlighter-rouge">setImmediate()</code>, но это легаси, и это вряд ли изменится — если это поменять, мы сломаем огромное количество пакетов в <code class="language-plaintext highlighter-rouge">npm</code>. Каждый день в <code class="language-plaintext highlighter-rouge">npm</code> добавляются новые модули, каждый день добавляется больше потенциальных поломок. Имена могут сбивать с толку, но они не изменятся.</p> <p>Рекомендуется во всех случаях использовать <code class="language-plaintext highlighter-rouge">setImmediate()</code> и забыть о <code class="language-plaintext highlighter-rouge">process.nextTick()</code>. Совсем.</p> <h4 id="но-в-каких-случаях-использовать-processnexttick">Но в каких случаях использовать process.nextTick()?</h4> <p>Есть две причины:</p> <ol> <li>Разрешить пользователям обрабатывать ошибки, очищать все ненужные ресурсы или, возможно, повторить запрос снова перед тем, как event loop продолжится.</li> <li>Иногда нам нужно разрешить выполнение коллбека после раскручивания стека вызовов, но до продолжения event loop.</li> </ol> <p>Вот пример:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">server</span> <span class="o">=</span> <span class="nx">net</span><span class="p">.</span><span class="nx">createServer</span><span class="p">();</span>
<span class="nx">server</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">connection</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">conn</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{});</span>

<span class="nx">server</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="mi">8080</span><span class="p">);</span>
<span class="nx">server</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">listening</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{});</span>
</code></pre></div></div> <p>Предположим, что <code class="language-plaintext highlighter-rouge">listen</code> запускается в начале event loop, но коллбек <code class="language-plaintext highlighter-rouge">listening</code> помещен в <code class="language-plaintext highlighter-rouge">setImmediate()</code>.Если имя хоста не передано, привязка к порту произойдет немедленно. Чтобы event loop продолжился, он лджлжен добраться до фазы poll — то есть существует ненулевая вероятность, что мы получим соединение и запустим событие <code class="language-plaintext highlighter-rouge">connection</code> до события <code class="language-plaintext highlighter-rouge">listening</code>.</p> <p>Вот другой пример — расширение <code class="language-plaintext highlighter-rouge">EventEmitter</code> и отправка события из конструктора:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">EventEmitter</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">events</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">class</span> <span class="nx">MyEmitter</span> <span class="kd">extends</span> <span class="nx">EventEmitter</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">();</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">emit</span><span class="p">(</span><span class="dl">'</span><span class="s1">event</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">myEmitter</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyEmitter</span><span class="p">();</span>
<span class="nx">myEmitter</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">event</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">an event occurred!</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div> <p>Нельзя сгенерировать событие из конструктора, поскольку скрипт не будет обработан до момента, когда пользователь назначает коллбек этому ивенту. Таким образом, внутри самого конструктора мы можем использовать <code class="language-plaintext highlighter-rouge">process.nextTick()</code>, чтобы установить коллбек для отправки <code class="language-plaintext highlighter-rouge">event</code> после того, как конструктор завершен — то есть все произойдет так, как мы и ожидаем.</p> <h2 id="выводы">Выводы</h2> <p>Асинхронность — важнейшая тема в JavaScript. Понимая все тонкости того, как все это работает изнутри, можно писать гораздо более предсказуемый и производительный код. И да, есть соблазн пропустить к чертям теорию, попытавшись не вникать в теорию (которая и вправду сложна) — но я бы крайне рекомендовал вникнуть в теорию, это даст вам возможность писать код намного более осознанно. И да, о теории — напоследок я порекомендую <a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ">вот это</a> выступление Филиппа Робертса с JSConf о event loop — в дополнение к этой статье это добавит вам понимания того, как все-таки однопоточный JavaScript работает асинхронно и очень быстро. Enjoy</p>]]></content><author><name></name></author><category term="javascript"/><category term="js"/><summary type="html"><![CDATA[Достаточно важная как для браузерного JS, так и для Node.js (на котором мы остановимся подробнее) тема — асинхронность. Все мы слышали и знаем, что JavaScript — язык асинхронный, и все мы знаем, что он еще и однопоточный.]]></summary></entry><entry><title type="html">Контекст выполнения функции (this) в JS</title><link href="https://sptmru.github.io/2023/execution-context-in-js/" rel="alternate" type="text/html" title="Контекст выполнения функции (this) в JS"/><published>2023-02-03T15:31:43+04:00</published><updated>2023-02-03T15:31:43+04:00</updated><id>https://sptmru.github.io/2023/execution-context-in-js</id><content type="html" xml:base="https://sptmru.github.io/2023/execution-context-in-js/"><![CDATA[<p>Очень популярный вопрос в моей менторской практике: что такое <code class="language-plaintext highlighter-rouge">this</code> и как оно работает? Давайте так: я возьму и сразу расскажу, что это такое.</p> <p>У функции в JS есть контекст выполнения. Так вот, <code class="language-plaintext highlighter-rouge">this</code> — и есть этот самый контекст выполнения :) стало понятнее? Вот-вот. Давайте разбираться подробнее.</p> <p>Как мы можем выполнить функцию в JavaScript? Есть всего четыре способа:</p> <ul> <li>напрямую вызвав функцию: <code class="language-plaintext highlighter-rouge">func();</code></li> </ul> <p>Вызвав функцию напрямую в нестрогом режиме (о котором стоит сразу забыть и никогда не использовать), <code class="language-plaintext highlighter-rouge">this</code> будет равен глобальному объекту <code class="language-plaintext highlighter-rouge">global</code> (или <code class="language-plaintext highlighter-rouge">window</code>, если мы о браузере, но мы тут все же про Node.js больше). Если же вызвать функцию напрямую в строгом режиме, то this у этой функции будет равен <code class="language-plaintext highlighter-rouge">undefined</code>. Вот так все просто.</p> <ul> <li>вызвав метод объекта: <code class="language-plaintext highlighter-rouge">obj.func();</code></li> </ul> <p>Если функция — это свойство объекта, то мы называем ее методом этого объекта. В таком случае this в этой функции — это этот самый объект. Все еще просто, да?</p> <ul> <li>вызвав функцию-конструктор, создав объекта, для чего у нас есть ключевое слово <code class="language-plaintext highlighter-rouge">new</code>:</li> </ul> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Book</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">book</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Book</span><span class="p">(</span><span class="dl">'</span><span class="s1">Bible</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">book</span><span class="p">.</span><span class="nx">name</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">Bible</span><span class="dl">'</span><span class="p">;</span> <span class="c1">// true</span>
</code></pre></div></div> <p>Вот тут уже чуть веселее. Если по-простому, то значением this здесь будет объект, который мы конструктором создали. Если чуть сложнее, то на самом деле происходит что-то вроде этого:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">Book</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// this = {} (this создается как некий объект)</span>
 <span class="c1">// return this (когда мы создаем объект конструктором, мы, собственно, и возвращаем этот самый this</span>
<span class="p">}</span>
</code></pre></div></div> <p>Как-то так. Все еще не слишком сложно, если вглядеться.</p> <p>Разберем последний вариант вызова функции — непрямой ее вызов. Тут мы встретим три новых метода: <code class="language-plaintext highlighter-rouge">bind()</code>, <code class="language-plaintext highlighter-rouge">call()</code> и <code class="language-plaintext highlighter-rouge">apply()</code>.</p> <p>Собственно, что мы можем с ними сделать? А сделать мы можем довольно интересную штуку — назначить контекст выполнения функции явно. Глядите:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">logNameEmailAndBirthDate</span><span class="p">(</span><span class="nx">birthDate</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">, </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">email</span><span class="p">}</span><span class="s2">, </span><span class="p">${</span><span class="nx">birthDate</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">user1</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Ivan</span><span class="dl">'</span><span class="p">,</span> <span class="na">email</span><span class="p">:</span> <span class="dl">'</span><span class="s1">ivan@gmail.com</span><span class="dl">'</span> <span class="p">};</span>
<span class="kd">const</span> <span class="nx">user2</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Petr</span><span class="dl">'</span><span class="p">,</span> <span class="na">email</span><span class="p">:</span> <span class="dl">'</span><span class="s1">petr@gmail.com</span><span class="dl">'</span> <span class="p">};</span>

<span class="nx">logNameEmailAndBirthDate</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">user1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">1 Oct 1991</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// this === user1</span>
<span class="nx">logNameEmailAndBirthDate</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">user2</span><span class="p">,</span> <span class="p">[</span><span class="dl">'</span><span class="s1">3 Feb 1993</span><span class="dl">'</span><span class="p">]);</span> <span class="c1">// this === user2</span>
</code></pre></div></div> <p>Что здесь происходит? А все просто: и <code class="language-plaintext highlighter-rouge">call()</code>, и <code class="language-plaintext highlighter-rouge">apply()</code> первым аргументом принимают this для функции, которую мы через эти <code class="language-plaintext highlighter-rouge">call()</code>, и <code class="language-plaintext highlighter-rouge">apply()</code> не напрямую вызываем. То есть в первом вызове <code class="language-plaintext highlighter-rouge">logNameEmailAndBirthDate()</code> (через <code class="language-plaintext highlighter-rouge">call()</code>) <code class="language-plaintext highlighter-rouge">this === user1</code>, во втором (через <code class="language-plaintext highlighter-rouge">apply()</code>) <code class="language-plaintext highlighter-rouge">this === user2</code>. Единственная разница между <code class="language-plaintext highlighter-rouge">call()</code> и <code class="language-plaintext highlighter-rouge">apply()</code> — первый принимает аргументы для функции через запятую, второй — массивом.</p> <p>А метод <code class="language-plaintext highlighter-rouge">bind()</code> делает похожую штуку, но — немного иначе. Смотрите:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">logNameAndEmail</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="s2">: </span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">email</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">bob</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Bob</span><span class="dl">'</span><span class="p">,</span> <span class="na">email</span><span class="p">:</span> <span class="dl">'</span><span class="s1">bob@gmail.com</span><span class="dl">'</span> <span class="p">};</span>
<span class="kd">const</span> <span class="nx">logNameAndEmailForBob</span> <span class="o">=</span> <span class="nx">logNameAndEmail</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">bob</span><span class="p">);</span>

<span class="nx">logNameAndEmailForBob</span><span class="p">();</span> <span class="c1">// Bob: bob@gmail.com</span>
</code></pre></div></div> <p>Что здесь происходит? Мы вызываем <code class="language-plaintext highlighter-rouge">bind()</code> для <code class="language-plaintext highlighter-rouge">logNameAndEmail()</code>, который привязывает контекст (<code class="language-plaintext highlighter-rouge">bob</code>) к <code class="language-plaintext highlighter-rouge">logNameAndEmail()</code>, возвращая новую функцию (в отличие от <code class="language-plaintext highlighter-rouge">call()</code>, и <code class="language-plaintext highlighter-rouge">apply()</code>), связанную с этим контекстом навсегда — изменить его потом не получится.</p> <h2 id="стрелочные-функции">Стрелочные функции</h2> <p>Отдельно стоит упомянуть стрелочные функции (<code class="language-plaintext highlighter-rouge">const func1 = () =&gt; {}</code>) — у них своего контекста выполнения, своего <code class="language-plaintext highlighter-rouge">this</code> попросту нет. Это работает так, будто они — результат выполнения <code class="language-plaintext highlighter-rouge">bind()</code> c ближайшим по иерархии контекстом.</p> <p>Это можно использовать, например, когда мы не хотим использовать bind, но хотим передать, скажем, родительский контекст выполнения в функцию.</p> <h2 id="каррирование">Каррирование</h2> <p>Один из классных примеров можно найти в функциональном программировании — каррирование. Каррирование — это трансформация функций так, чтобы они принимали значения не так: <code class="language-plaintext highlighter-rouge">func (a, b, c)</code>, а так: <code class="language-plaintext highlighter-rouge">func(a)(b)(c)</code>.</p> <p>Зачем это нужно? Давайте рассмотрим это на примере функции, суммирующей все свои аргументы. Вы скажете, что для этого можно сделать так:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">sumAll</span> <span class="p">(...</span><span class="nx">spr</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">spr</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">partialSum</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">partialSum</span> <span class="o">+</span> <span class="nx">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>И — да, так можно. Но мы все же возьмем это как пример для каррирования, тем более, что он будет не единственным. Давайте напишем ту самую трансформирующую функцию <code class="language-plaintext highlighter-rouge">curry()</code>, используя наши знания о методе <code class="language-plaintext highlighter-rouge">apply()</code>:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span> <span class="o">+</span> <span class="nx">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">curry</span> <span class="p">(</span><span class="nx">func</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="nx">curried</span><span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;=</span> <span class="nx">func</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">func</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kd">function</span><span class="p">(...</span><span class="nx">args2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">curried</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">args</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">args2</span><span class="p">));</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">curriedSummer</span> <span class="o">=</span> <span class="nx">curry</span><span class="p">(</span><span class="nx">sum</span><span class="p">);</span>

<span class="c1">// 6, можем просто вызвать функцию частично</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">curriedSummer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="p">);</span>
<span class="c1">// все еще 6, мы прокаррировали первый аргумент</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">curriedSummer</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="p">);</span> 
<span class="c1">// и тут 6, мы прокаррирровали все аргументы</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">curriedSummer</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="mi">2</span><span class="p">)(</span><span class="mi">3</span><span class="p">)</span> <span class="p">);</span> 
</code></pre></div></div> <p>Функция <code class="language-plaintext highlighter-rouge">curry(func)</code> выглядит сложновато — давайте разберем ее. Она возвращает функцию <code class="language-plaintext highlighter-rouge">curried()</code>, принимающую неограниченное количество аргументов. Что она делает. Она:</p> <ul> <li>если количество переданных в <code class="language-plaintext highlighter-rouge">curried()</code> аргументов больше или равно количеству аргументов при объявлении функции <code class="language-plaintext highlighter-rouge">func()</code> (в примере ниже <code class="language-plaintext highlighter-rouge">sum()</code>), то мы просто вызываем функцию <code class="language-plaintext highlighter-rouge">func()</code> , используя <code class="language-plaintext highlighter-rouge">apply()</code></li> <li>если же количество переданных аргументов меньше количества аргументов при объявлении функции, мы не выполним <code class="language-plaintext highlighter-rouge">func()</code> сразу: вместо этого мы вернем новую функцию, которая снова применит curried, передав предыдущие аргументы вместе с новыми. И так будет происходить до тех пор, пока аргументов будет достаточно для вызова <code class="language-plaintext highlighter-rouge">func()</code>, которую мы и вызовем.</li> </ul> <p>Пример с суммированием надуман, конечно. Но есть известный пример с функцией для логирования. Смотрите: у нас есть вот такая вот функция:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">log</span><span class="p">(</span><span class="nx">level</span><span class="p">,</span> <span class="nx">date</span><span class="p">,</span> <span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`[</span><span class="p">${</span><span class="nx">date</span><span class="p">.</span><span class="nx">getHours</span><span class="p">()}</span><span class="s2">:</span><span class="p">${</span><span class="nx">date</span><span class="p">.</span><span class="nx">getMinutes</span><span class="p">()}</span><span class="s2">] [</span><span class="p">${</span><span class="nx">level</span><span class="p">}</span><span class="s2">] </span><span class="p">${</span><span class="nx">message</span><span class="p">}</span><span class="s2">`</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// и этим даже можно пользоваться:</span>

<span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">DEBUG</span><span class="dl">"</span><span class="p">,</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">(),</span> <span class="dl">'</span><span class="s1">debug message</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// [23:33] [DEBUG] debug message</span>
</code></pre></div></div> <p>Но что, если мы применим к ней каррирование?</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">curriedLog</span> <span class="o">=</span> <span class="nx">curry</span><span class="p">(</span><span class="nx">log</span><span class="p">);</span>

<span class="c1">// после этого мы сможем пользоваться ей, как раньше: </span>
<span class="nx">curriedLog</span><span class="p">(</span><span class="dl">"</span><span class="s2">DEBUG</span><span class="dl">"</span><span class="p">,</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">(),</span> <span class="dl">'</span><span class="s1">debug message</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// [23:33] [DEBUG] debug message</span>

<span class="c1">// но мы можем сделать и так:</span>
<span class="nx">curriedLog</span><span class="p">(</span><span class="dl">"</span><span class="s2">DEBUG</span><span class="dl">"</span><span class="p">)(</span><span class="k">new</span> <span class="nb">Date</span><span class="p">(),</span> <span class="dl">'</span><span class="s1">debug message</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// [23:33] [DEBUG] debug message</span>
</code></pre></div></div> <p>Пока вообще не понятно, зачем мы это все затеяли. Но смотрите, что полезного мы можем из этого вывести:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">debugLog</span> <span class="o">=</span> <span class="nx">curriedLog</span><span class="p">(</span><span class="dl">"</span><span class="s2">DEBUG</span><span class="dl">"</span><span class="p">);</span>

<span class="nx">debugLog</span><span class="p">(</span><span class="k">new</span> <span class="nb">Date</span><span class="p">(),</span> <span class="dl">'</span><span class="s1">debug message</span><span class="dl">'</span><span class="p">);</span>
<span class="c1">// [23:33] [DEBUG] debug message</span>
</code></pre></div></div> <p>Видите? С помощью каррирования первого аргумента мы можем для разных уровней логирования создать функции <code class="language-plaintext highlighter-rouge">debugLog()</code>, <code class="language-plaintext highlighter-rouge">errorLog()</code> и так далее, и нам не придется постоянно передавать level логирования в функцию! Мы можем даже пойти дальше и откаррировать второй аргумент, получив функцию типа <code class="language-plaintext highlighter-rouge">debugLogForCurrentDate(message)</code>, в которую даже дату передавать не нужно! Этот пример кажется надуманным, но можно найти этому множество гораздо более полезных применений.</p> <h2 id="итоги">Итоги</h2> <p>Гибкость контекста выполнения функции в JS делает его очень гибким языком, позволяя делать очень многие штуки, которые в других, менее гибких языках так красиво просто не делаются. И, в общем-то, this — это не очень-то и сложно :)</p>]]></content><author><name></name></author><category term="javascript"/><category term="js"/><summary type="html"><![CDATA[Статья о this в JavaScript, и обо всем, что с этим связано]]></summary></entry><entry><title type="html">Прототипное наследование в JS</title><link href="https://sptmru.github.io/2023/prototype-inheritance-in-js/" rel="alternate" type="text/html" title="Прототипное наследование в JS"/><published>2023-02-03T15:31:43+04:00</published><updated>2023-02-03T15:31:43+04:00</updated><id>https://sptmru.github.io/2023/prototype-inheritance-in-js</id><content type="html" xml:base="https://sptmru.github.io/2023/prototype-inheritance-in-js/"><![CDATA[<p>Очень популярный вопрос от моих менти, его задают стабильно: «Что такое прототипное наследование в JS? Как оно работает? Чем отличается от наследования в других языках?»</p> <p>Поскольку вопрос достаточно тривиальный, решил сюда набросать небольшую статью (да, я в курсе, в общем-то, что linkedin — не то чтобы лучшая платформа для технических статей, но я иногда что-то такое пишу, и, судя по лайкам, моей аудитории вполне заходит).</p> <p>Так вот: для того, чтобы понять, почему такой вопрос вообще возникает и чем наследование в JS отличается от классического наследования в ООП, давайте это самое классическое наследование рассмотрим.</p> <p>Классическое наследование работает примерно так: есть родительский класс, когда мы наследуем от него другой класс, в него копируются атрибуты и методы родительского класса. В общем-то, это все. Вот так вот просто.</p> <p>Почему так нельзя в JavaScript? И тут тоже все просто — в JS классов нет. Есть объекты. Конечно, есть ключевое слово <code class="language-plaintext highlighter-rouge">class</code> — правда, оно, во-первых, появилось сравнительно недавно, в 2015 году, вместе с ES6, а, во-вторых, не создает на самом деле никаких классов — оно все еще создает те же объекты.</p> <p>Так как реализовать что-то похожее на классическое ООП-наследование, не имея классов? В JavaScript у объектов есть скрытое свойство <code class="language-plaintext highlighter-rouge">[[Prototype]]</code>. Свойство это может быть либо равным <code class="language-plaintext highlighter-rouge">null</code>, либо содержать в себе ссылку на другой объект.</p> <p>Собственно, так мы и реализуем наследование: если мы пытаемся прочитать свойство или использовать метод объекта, а его в этом объекте нет, JS смотрит в его прототип, если находит там ссылку на объект, то ищет это свойство или метод уже в этом объекте. Если и там его нет, JS смотрит в прототип уже этого объекта — если и там нужного метода / свойства, JS снова идет в прототип — и так либо пока не найдет нужный метод / свойство, либо не встретит в прототипе null.</p> <p>В таком случае JS либо вернет undefined, если мы искали свойство, либо, если мы искали функцию, упадет с <code class="language-plaintext highlighter-rouge">TypeError: obj.nonExistingMethod is not a function</code>.</p> <p>Это и называется прототипным наследованием в JavaScript.</p> <p>Кстати, из этого всего можно сделать два интересных вывода: во-первых, нужно стараться не делать цепочки связанных через прототипы объекты слишком длинными, чтобы не влиять на производительность негативно. Во-вторых, наследование в JavaScript как минимум не слабее классического — к примеру, мы можем отнаследовать класс от другого уже после его создания.</p> <p>Теперь немного о практике. К прототипу объекта мы можем обращаться либо через геттер / сеттер <code class="language-plaintext highlighter-rouge">__proto__</code> (<code class="language-plaintext highlighter-rouge">obj.__proto__ = anotherObj</code>), либо (более современный способ) использовать методы <code class="language-plaintext highlighter-rouge">Object.getPrototypeOf(obj)</code> и <code class="language-plaintext highlighter-rouge">Object.setPrototypeOf(obj, prototype)</code>. Еще мы можем делать <code class="language-plaintext highlighter-rouge">class ClassSecond extends ClassFirst</code> — по сути, раньше мы бы сделали то же самое так: <code class="language-plaintext highlighter-rouge">ClassSecond.__proto__ = ClassFirst</code> или <code class="language-plaintext highlighter-rouge">Object.setPrototypeOf(ClassSecond, ClassFirst)</code>.</p> <p>Здесь стоит упомянуть цикл <code class="language-plaintext highlighter-rouge">for..in</code> — он перебирает не только свойства самого объекта, но и унаследованные. То есть, следующий код выведет свойства как объекта obj2, так и объекта obj1, от которого он унаследован:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">obj1</span> <span class="o">=</span> <span class="p">{</span> <span class="na">test1</span><span class="p">:</span> <span class="dl">'</span><span class="s1">test1</span><span class="dl">'</span><span class="p">,</span> <span class="na">test2</span><span class="p">:</span> <span class="dl">'</span><span class="s1">test2</span><span class="dl">'</span> <span class="p">};</span>
<span class="kd">const</span> <span class="nx">obj2</span> <span class="o">=</span> <span class="p">{</span> <span class="na">test3</span><span class="p">:</span> <span class="dl">'</span><span class="s1">test3</span><span class="dl">'</span><span class="p">,</span> <span class="na">test4</span><span class="p">:</span> <span class="dl">'</span><span class="s1">test4</span><span class="dl">'</span> <span class="p">};</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">obj2</span><span class="p">,</span> <span class="nx">obj1</span><span class="p">);</span> <span class="c1">// наследуем obj2 от obj1</span>

<span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">prop</span> <span class="k">in</span> <span class="nx">obj2</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">prop</span><span class="p">}</span><span class="s2">: </span><span class="p">${</span><span class="nx">obj2</span><span class="p">[</span><span class="nx">prop</span><span class="p">]}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// выведет:</span>

<span class="nl">test3</span><span class="p">:</span> <span class="nx">test3</span>
<span class="nx">test4</span><span class="p">:</span> <span class="nx">test4</span>
<span class="nx">test1</span><span class="p">:</span> <span class="nx">test1</span>
<span class="nx">test2</span><span class="p">:</span> <span class="nx">test2</span>

</code></pre></div></div> <p>Как небольшой итог: прототипное наследование ничем не хуже, а иногда и лучше классического. Да и понять его не так и сложно.</p>]]></content><author><name></name></author><category term="javascript"/><category term="js"/><summary type="html"><![CDATA[Статья о реализации наследования в JS и всем, что с этим связано]]></summary></entry></feed>