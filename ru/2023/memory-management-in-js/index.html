<!DOCTYPE html> <html lang="ru"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content="352510442"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Управление памятью в JS | Сослан Алдатов | Бэкенд-разработка, VoIP, DevOps, фриланс</title> <meta name="author" content="Сослан Алдатов"> <meta name="description" content="Статья о cборке мусора в JavaScript — то, что часто остается незаметным"> <meta name="keywords" content="sptm, sptmru, Soslan Aldatov, Node.js, JavaScript, backend, VoIP, Asterisk, FreeSWITCH, Kamailio, OpenSIPs, Drachtio"> <meta property="og:site_name" content="Сослан Алдатов | Бэкенд-разработка, VoIP, DevOps, фриланс"> <meta property="og:type" content="website"> <meta property="og:title" content="Сослан Алдатов | Бэкенд-разработка, VoIP, DevOps, фриланс | Управление памятью в JS"> <meta property="og:url" content="https://sptm.dev/ru/2023/memory-management-in-js/"> <meta property="og:description" content="Статья о cборке мусора в JavaScript — то, что часто остается незаметным"> <meta property="og:locale" content="ru"> <meta name="twitter:card" content="summary"> <meta name="twitter:title" content="Управление памятью в JS"> <meta name="twitter:description" content="Статья о cборке мусора в JavaScript — то, что часто остается незаметным"> <meta name="twitter:site" content="@sptmru"> <meta name="twitter:creator" content="@sptmru"> <script type="application/ld+json">
    {
      "author":
      {
        "@type": "Person",
        "name": "Сослан Алдатов"
      },
      "url": "https://sptm.dev/ru/2023/memory-management-in-js/",
      "@type": "WebSite",
      "description": "Статья о cборке мусора в JavaScript — то, что часто остается незаметным",
      "headline": "Управление памятью в JS",
      "sameAs": ["https://github.com/sptmru", "https://telegram.me/sptm_dev", "https://www.linkedin.com/in/sptm", "https://twitter.com/sptmru", "https://gitlab.com/sptmru", "https://stackoverflow.com/users/5470429/sptm", "https://www.last.fm/user/sptmru"],
      "name": "Сослан Алдатов",
      "@context": "https://schema.org"
    }
</script> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <script type="text/javascript">!function(e,t,c,n,r,a,s){e[r]=e[r]||function(){(e[r].a=e[r].a||[]).push(arguments)},e[r].l=1*new Date;for(var i=0;i<document.scripts.length;i++)if(document.scripts[i].src===n)return;a=t.createElement(c),s=t.getElementsByTagName(c)[0],a.async=1,a.src=n,s.parentNode.insertBefore(a,s)}(window,document,"script","https://mc.yandex.ru/metrika/tag.js","ym"),ym(92729596,"init",{clickmap:!0,trackLinks:!0,accurateTrackBounce:!0,webvisor:!0});</script> <noscript><div><img src="https://mc.yandex.ru/watch/92729596" style="position:absolute; left:-9999px;" alt=""></div></noscript> <script src="https://8x8.vc/vpaas-magic-cookie-7a577401e6ff45bc9738555943af1a51/external_api.js" async></script> <style>html,body,#jaas-container{height:100%}</style> <script type="text/javascript">window.onload=(()=>{new JitsiMeetExternalAPI("8x8.vc",{roomName:"vpaas-magic-cookie-7a577401e6ff45bc9738555943af1a51/SampleAppCoastalDonationsContinueInitially",parentNode:document.querySelector("#jaas-container")})});</script> <link rel="shortcut icon" href="/assets/img/apple-icon-120x120.png"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://sptm.dev/ru/2023/memory-management-in-js/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="navbar-collapse collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/ru/">главная</a> </li> <li class="nav-item "> <a class="nav-link" href="/ru/blog/">блог <span class="sr-only">(current)</span> </a> </li> <li class="nav-item"> <a class="nav-link" href="/">english</a> </li> <span class="nav-item">/</span> <li class="nav-item active"> <a class="nav-link" href="/ru/">русский</a> </li> <li class="nav-item active" toogle theme mode> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <meta property="og:type" content="article"> <h1 class="post-title">Управление памятью в JS</h1> <p class="post-meta">February 26, 2023</p> <p class="post-tags"> <a href="/ru/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/ru/blog/tag/js"> <i class="fas fa-hashtag fa-sm"></i> js</a>     ·   <a href="/ru/blog/category/javascript"> <i class="fas fa-tag fa-sm"></i> javascript</a>   </p> </header> <article class="post-content"> <h2 id="введение">Введение</h2> <p>JavaScript (а точнее, V8) управляет памятью незаметно для нас, и писать код можно, вообще об этом не заморачиваясь. Но чем серьезнее проект, тем больше приходится беспокоиться об этом, не допускать утечек памяти и в принципе понимать, как оно работает под капотом. Об этом я сегодня и постараюсь рассказать. Статья, наверное, получится не совсем для новичков — но и им это может быть интересно.</p> <h2 id="garbage-collector-сборщик-мусора">Garbage Collector (сборщик мусора)</h2> <p>Вот мы пишем код, создаем функции, объекты, генераторы, <a href="https://sptm.dev/ru/2023/proxy-and-reflect/">Proxy и Reflect</a>, вот это все. Очевидно, оно занимает оперативную память (если чуточку подробнее, то примитивы хранятся в стеке, а все остальное — в куче, но сейчас это не так важно для нас). Соответственно, существует некий жизненный цикл памяти. Давайте о нем чуть подробнее.</p> <h3 id="выделение-памяти">Выделение памяти</h3> <p>Каждый раз, когда мы что-то в нашем коде создаем (переменную, функцию, вот это все), JavaScript незаметно для нас выделяет под это кусок памяти. Собственно, пока это все — дальше мы разберем это подробнее в главе о стеке и куче.</p> <h3 id="использование-памяти">Использование памяти</h3> <p>Этот процесс намного ближе к нам: создавая что-то, мы в память это пишем, используя — читаем. Да, вот так все просто.</p> <h3 id="освобождение-памяти">Освобождение памяти</h3> <p>Это за нас тоже делает JS (V8), и делает он это незаметно для нас. Приятно писать на языках высокого уровня, правда? Дальше разберем, как и когда он это делает.</p> <h2 id="стек-и-куча">Стек и куча</h2> <p>Выделение памяти — понятие очень абстрактное. А где именно хранятся примитивы, функции, объекты? Есть две таких структуры данных: стек и куча. Давайте о них подробнее.</p> <h3 id="стек-статическое-выделение-памяти">Стек (статическое выделение памяти)</h3> <p>Стек — это, во-первых, такая структура данных. Список элементов, которые организованы и обрабатываются по принципу <a href="https://ru.wikipedia.org/wiki/LIFO" rel="external nofollow noopener" target="_blank">LIFO</a> — last in, first out (последним пришел, первым ушел). По этому поводу можно глянуть <a href="https://sptm.dev/ru/2023/asynchrony-in-js/">мою статью об асинхронности в JS</a>, но там не совсем об этом.</p> <p>А во-вторых, это место, где JS хранит примитивные значения (<code class="language-plaintext highlighter-rouge">string</code>, <code class="language-plaintext highlighter-rouge">number</code>, <code class="language-plaintext highlighter-rouge">boolean</code>, <code class="language-plaintext highlighter-rouge">null</code>, <code class="language-plaintext highlighter-rouge">undefined</code>) и ссылки на объекты (на все, что не примитивные значения). Размер таких данных не изменится, поэтому движку удобно — он выделяет фиксированный объем памяти для каждого значения. Процесс выделения памяти прямо перед выполнением называется статическим. Кстати, на размер примитивных значений существует нефиксированный лимит данных. Но то такое, не так важно, как лимит памяти для кучи.</p> <h3 id="куча-динамическое-выделение-памяти">Куча (динамическое выделение памяти)</h3> <p>Куча, если сильно углубиться, это такое <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_(%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)" rel="external nofollow noopener" target="_blank">дерево</a>, но нам это не так важно. А важно то, что все, что не примитивы, JS хранит в куче. Если для примитивов заранее известен размер, то объекты, функции и все такое фиксированного размера не имеют. Поэтому JS выделяет память по мере необходимости (динамически), что может порождать утечки памяти (об этом позже).</p> <p>Давайте набросаем небольшой пример — без кода скучновато:</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">val1</span><span class="p">:</span> <span class="dl">'</span><span class="s1">1</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">val2</span><span class="p">:</span> <span class="dl">'</span><span class="s1">2</span><span class="dl">'</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// под этот объект JS выделит память в куче — черт его знает, сколько свойств мы добавим / удалим / поменяем позже</span>
<span class="c1">// кстати, свойства этого объекта — вполне себе примитивы</span>

<span class="kd">const</span> <span class="nx">arr1</span> <span class="o">=</span> <span class="p">[</span> <span class="dl">'</span><span class="s1">string1</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">string2</span><span class="dl">'</span> <span class="p">];</span>

<span class="c1">// массив — это объект, и под него память тоже выделится в куче</span>

<span class="kd">const</span> <span class="nx">test1</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">test1</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">test2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="c1">// а вот это — примитивы. Они хранятся в стеке. Кстати, интересный факт: примитивы неизменяемы, пофиг, объявлены они как var, let или const</span>
<span class="c1">// вместо изменения примитивов JS создает новые.</span>
</code></pre></div></div> <h3 id="ссылки-не-те-что-в-http">Ссылки (не те, что в <a href="https://sptm.dev/ru/2023/http-in-details/">HTTP</a>)</h3> <p>Все переменные (пофиг, на что они указывают / что хранят) хранятся в стеке. Примитивы там хранятся в прямом смысле. С остальным чуть сложнее: в стеке хранятся ссылки на них в куче. В куче порядка нет, поэтому JS и хранит ссылки на них в стеке.</p> <h2 id="концепт-достижимости">Концепт достижимости</h2> <p>Достижимость — сверхважное понятие для того, чтобы понять, как работает сборка мусора. Но ничего шибко сложного в этом нет. Давайте просто: достижимые значения — это те, что находятся в стеке (или ссылка на них находится в стеке). Примеры корневых достижимых значений: выполняемая в текущий момент функция, ее переменные и параметры, другие функции во вложенной цепочке вызовов (и их параметры и переменные), глобальные значения. А любое другое значение будет достижимым, если они доступны из корневых достижимых значений.</p> <p>Давайте по примерам:</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// в obj1 находится ссылка на объект в куче, а свойство prop1, как примитив, хранится в стеке. Оба значения достижимы,</span>
<span class="kd">let</span> <span class="nx">obj1</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">prop1</span><span class="p">:</span> <span class="dl">'</span><span class="s1">1</span><span class="dl">'</span><span class="p">,</span>
<span class="p">}</span>
<span class="c1">// обнуляем obj1, и ссылка теряется. Объект obj1 и его свойства становятся недостижимыми</span>
<span class="nx">obj1</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</code></pre></div></div> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// а если так?</span>
<span class="kd">let</span> <span class="nx">obj1</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">prop1</span><span class="p">:</span> <span class="dl">'</span><span class="s1">1</span><span class="dl">'</span><span class="p">,</span>
<span class="p">}</span>
<span class="kd">const</span> <span class="nx">obj2</span> <span class="o">=</span> <span class="nx">obj1</span><span class="p">;</span>
<span class="nx">obj1</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="c1">// хоть мы и обнулили ссылку в obj1, ссылка на этот объекта осталась в obj2, поэтому он все еще достижим</span>
</code></pre></div></div> <h4 id="взаимосвязанные-объекты">Взаимосвязанные объекты</h4> <p>Чуть сложнее:</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">combine</span><span class="p">(</span><span class="nx">val1</span><span class="p">,</span> <span class="nx">val2</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">val1</span><span class="p">.</span><span class="nx">prop1</span> <span class="o">=</span> <span class="nx">val2</span><span class="p">;</span>
    <span class="nx">val2</span><span class="p">.</span><span class="nx">prop2</span> <span class="o">=</span> <span class="nx">val1</span><span class="p">;</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="na">prop1</span><span class="p">:</span> <span class="nx">val1</span><span class="p">,</span>
        <span class="na">prop2</span><span class="p">:</span> <span class="nx">val2</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">combinedValues</span> <span class="o">=</span> <span class="nf">combine</span><span class="p">({</span>
    <span class="na">property1</span><span class="p">:</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span>
<span class="p">},</span> <span class="p">{</span>
    <span class="na">property2</span><span class="p">:</span> <span class="dl">"</span><span class="s2">2</span><span class="dl">"</span>
<span class="p">});</span>
</code></pre></div></div> <p>Что мы тут сделали? Функция <code class="language-plaintext highlighter-rouge">combine()</code> пересекает объекты, давая им ссылки друг на друга, возвращая объект со ссылками на два предыдущих. Сейчас все объекты достижимы. А если так?</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">delete</span> <span class="nx">combinedValues</span><span class="p">.</span><span class="nx">prop1</span><span class="p">;</span>
<span class="k">delete</span> <span class="nx">combinedValues</span><span class="p">.</span><span class="nx">prop2</span><span class="p">.</span><span class="nx">val2</span><span class="p">;</span>
</code></pre></div></div> <p>И все, у <code class="language-plaintext highlighter-rouge">prop2</code> входящих ссылок больше нет. Но если не удалять одну из ссылок, все объекты останутся достижимыми. А что еще прикольного можно сделать?</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">combinedValues</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// обнуляем combinedValues, он недостижим, и вместе с ним недостижимыми становятся его свойства</span>
</code></pre></div></div> <h2 id="сборка-мусора">Сборка мусора</h2> <p>Вообще, сборка мусора — процесс простой: когда объект/переменная недостижима, он очищает занимаемую ими память. Но проблема есть: однозначно решить, нужна ли выделенная память прямо в момент перехода ее в состояние недостижимости, не выйдет.</p> <p>Нужны какие-то алгоритмы, и они есть: они не полностью точны, но близки к тому. Два самых популярных таких алгоритма — это подсчет ссылок и алгоритм пометок (mark and sweep).</p> <h3 id="алгоритм-подсчета-ссылок">Алгоритм подсчета ссылок</h3> <p>Алгоритм супер-простой: он уничтожает объекты, на которые ссылок больше нет. Но есть проблемка: циклические ссылки он обрабатывать не умеет. Смотрите:</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">obj1</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">prop1</span><span class="p">:</span> <span class="dl">'</span><span class="s1">1</span><span class="dl">'</span><span class="p">,</span>
<span class="p">};</span>
<span class="kd">let</span> <span class="nx">obj2</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">prop2</span><span class="p">:</span> <span class="dl">'</span><span class="s1">2</span><span class="dl">'</span><span class="p">,</span>
<span class="p">}</span>

<span class="nx">obj1</span><span class="p">.</span><span class="nx">obj2</span> <span class="o">=</span> <span class="nx">obj2</span><span class="p">;</span>
<span class="nx">obj2</span><span class="p">.</span><span class="nx">obj2</span> <span class="o">=</span> <span class="nx">obj1</span><span class="p">;</span>
<span class="nx">obj1</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="nx">obj1</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</code></pre></div></div> <p>Вроде как мы обнулили <code class="language-plaintext highlighter-rouge">obj1</code> и <code class="language-plaintext highlighter-rouge">obj2</code>, в чем проблема признать их недостижимыми и очистить занимаемую ими память? Доступа к ним уже нет. Да вот только алгоритм, подсчитывающий ссылки, видит циклические ссылки объектов друг на друга и не считает их недостижимыми.</p> <h3 id="mark-and-sweep-алгоритм-пометок">Mark and Sweep (алгоритм пометок)</h3> <p>Проблему циклических ссылок решает алгоритм пометок. Как он работает? Тоже достаточно просто. Он проверяет, можно ли получить доступ к обьекту через корневой объект (в Node.js это <code class="language-plaintext highlighter-rouge">global</code>, в браузере — <code class="language-plaintext highlighter-rouge">window</code>). Он помечает недоступные объекты (mark) как недостижимые, а после выметает (sweep) их из памяти.</p> <h4 id="проблемы-алгоритмов-очистки-памяти">Проблемы алгоритмов очистки памяти</h4> <p>Есть беда: алгоритмы не знают, в какой момент память станет ненужной. И поэтому приложения на JS могут использовать больше памяти, чем им на самом деле нужно. Ко всему прочему, в однопоточном JS сборщик мусора не может работать постоянно, иначе наш код работать не будет вообще. Сборщик мусора запускается с некоторой периодичностью, но этой периодичностью управлять мы не можем.</p> <p>Для этого и существуют языки с ручным управлением памяти типа С или Rust. В Rust этот вопрос решен особенно интересно, почитайте <a href="https://doc.rust-lang.org/book/" rel="external nofollow noopener" target="_blank">документацию</a>, если интересно — полезно для эрудиции.</p> <h4 id="оптимизации-алгоритмов-очистки-памяти">Оптимизации алгоритмов очистки памяти</h4> <p>Движки JS стараются оптимизировать очистку памяти как можно эффективнее. Вот некоторые из интересных оптимизаций.</p> <h5 id="сборка-по-поколениям-generational-collection">Сборка по поколениям (Generational Collection)</h5> <p>Объекты делятся на два набора: старые и новые. Обычно многие объекты живут недолго: создаются, делают свою работу и умирают. Соответственно, имеет смысл новые объекты проверять чаще. Те, что не проверяются долго, считаются старыми и проверяются реже.</p> <h5 id="инкрементальная-сборка-incremental-collection">Инкрементальная сборка (Incremental collection)</h5> <p>Если объектов много, и сборщик мусора будет их все обходить, это будет долго. Поэтому множество всех объектов делится на части. Тогда одна большая сборка мусора превращается в несколько небольших, и это меньше блокирует поток (а он у нас один, читаем <a href="https://sptm.dev/ru/2023/asynchrony-in-js/">это</a>).</p> <h5 id="сборка-в-свободное-время-idle-time-collection">Сборка в свободное время (Idle-time collection)</h5> <p>А тут все просто: сборщик мусора старается работать тогда, когда процессор наименее загружен.</p> <h2 id="утечки-памяти">Утечки памяти</h2> <p>Давайте коротко разберем то, что делать не нужно, чтобы уменьшить вероятность утечек памяти.</p> <h3 id="глобальные-переменные">Глобальные переменные</h3> <p>Не используйте глобальные переменные! Не используйте <code class="language-plaintext highlighter-rouge">var</code> вместо <code class="language-plaintext highlighter-rouge">let</code> и <code class="language-plaintext highlighter-rouge">const</code>! Это присоединит переменную к глобальному объекту (<code class="language-plaintext highlighter-rouge">window</code> или <code class="language-plaintext highlighter-rouge">global</code>) и помешает алгоритму mark-and-sweep очищать занимаемую имм память, и ваше приложение потечет.</p> <h3 id="забытые-таймеры">Забытые таймеры</h3> <p>Забытые таймеры не очистятся никогда. Смотрите:</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">object</span> <span class="o">=</span> <span class="p">{};</span>
<span class="kd">const</span> <span class="nx">interval</span> <span class="o">=</span> <span class="nf">setInterval</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">doSomething</span><span class="p">(</span><span class="nx">object</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">2000</span><span class="p">);</span>
</code></pre></div></div> <p>Пока <code class="language-plaintext highlighter-rouge">interval</code> не будет очищен, каждые две секунды будет выполняться <code class="language-plaintext highlighter-rouge">doSomething(object)</code>. Не забывайте о <code class="language-plaintext highlighter-rouge">clearInterval</code>, очищайте интервалы!</p> <h2 id="итоги">Итоги</h2> <p>Итак, что нужно помнить:</p> <ul> <li>мы никак не можем повлиять на сборку мусора, она выполняется автоматически</li> <li>достижимые объекты занимают драгоценную память</li> <li>как мы видели в примерах выше, если на объект есть ссылка, он недостижим — смотрите примеры с взаимоссылающимися объектами</li> </ul> <p>А если хочется мясца про V8 и кишки, гляньте <a href="https://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection" rel="external nofollow noopener" target="_blank">офигенную статью</a> о деталях работы сборки мусора в V8.</p> <p>Понимать, как работает garbage collection, важно: если нам требуется низкоуровневая оптимизация, поэтому статейку прочитать полезно, Я не перевожу ее здесь, чтобы не усложнять статью. Всем спасибо за внимание, stay tuned!</p> </article> <h2>Интересный пост?</h2> <p>Вот еще похожие:</p> <ul> <li><a href="/ru/2023/event-emitter/">Событийно-ориентированная архитектура и Node.js Events</a></li> <li><a href="/ru/2023/reactive-programming/">Реактивное программирование: теория и практика</a></li> <li><a href="/ru/2023/application-testing/">Как и зачем писать тесты?</a></li> <li><a href="/ru/2023/functional-programming/">Функциональное программирование. Что это и зачем?</a></li> <li><a href="/ru/2023/profiling-nodejs-app/">Профилирование Node.js-приложений</a></li> </ul> <script id="diffblog-plugin-script" async="false" src="https://diff.blog/static/js/diffblog_plugin_v1.js"></script> <script>document.getElementById("diffblog-plugin-script").addEventListener("load",function(){DiffBlog("6it6gx3ne5id9kcpizdilzhhypm96tjh2yj8yfjey44gcmpx1y")});</script><div id="disqus_thread" style="max-width: 800px; margin: 0 auto;"> <script type="text/javascript">var disqus_shortname="https-sptm-dev",disqus_identifier="/2023/memory-management-in-js",disqus_title="\u0423\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u043f\u0430\u043c\u044f\u0442\u044c\u044e \u0432 JS";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}();</script> <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by Disqus.</a> </noscript> </div> </div> </div> <footer class="sticky-bottom mt-5"> <div class="container">По любым вопросам пишите на <a href="mailto:soslanaldatov@gmail.com">soslanaldatov@gmail.com</a> — я буду рад вам помочь!</div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script type="text/javascript">$(function(){$('[data-toggle="tooltip"]').tooltip()});</script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4551358636212260" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-P58WVSR9JS"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-P58WVSR9JS");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>