<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ru"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://sptm.dev/feed.xml" rel="self" type="application/atom+xml"/><link href="https://sptm.dev/" rel="alternate" type="text/html" hreflang="ru"/><updated>2024-10-25T19:48:02+00:00</updated><id>https://sptm.dev/feed.xml</id><title type="html">global.title</title><subtitle>global.description</subtitle><entry><title type="html">Событийно-ориентированная архитектура и Node.js Events</title><link href="https://sptm.dev/ru/2023/event-emitter/" rel="alternate" type="text/html" title="Событийно-ориентированная архитектура и Node.js Events"/><published>2023-03-14T02:50:43+00:00</published><updated>2023-03-14T02:50:43+00:00</updated><id>https://sptm.dev/ru/2023/event-emitter</id><content type="html" xml:base="https://sptm.dev/ru/2023/event-emitter/"><![CDATA[<h2 id="введение">Введение</h2> <p>Вообще, если бы мой блог был логичным, то эта статья вышла бы раньше предыдущей <a href="https://sptm.dev/ru/2023/reactive-programming/">статьи о реактивном программировании</a>, потому что штуки эти очень похожи. Я бы даже сказал, что реактивное программирование — это частный случай событийно-ориентированной архитектуры.</p> <p>Вообще, в JavaScript очень удобно работать с событиями. В Node.js API есть даже целый класс <a href="https://nodejs.org/api/events.html#class-eventemitter">EventEmitter</a>, который только этим и занимается. Да и в целом, само по себе Node.js API построено вокруг своеобразной асинхронной событийно-ориентированной архитектуры.</p> <p>Так что ж это за архитектура такая?</p> <h2 id="событийно-ориентированная-архитектура">Событийно-ориентированная архитектура</h2> <p>Событийно-ориентированная архитектура (многим гораздо привычнее видеть ее английское название, event-driven architecture), как понятно из названия, завязана на события. Создание событий и реагирование на них — это, в общем-то, вся ее суть.</p> <p>Событие — это некое изменение состояния (это уже сильно ближе к реактивному программированию, но все же). Давайте определим, какой путь проходит это самое событие.</p> <h3 id="генерация-события">Генерация события</h3> <p>Для начала событие должно случиться (ну, или появиться, кому как удобнее). Языком из Википедии скажем, что некий генератор событий регистрирует какой-то факт и создает событие. В JavaScript этим занимается <code class="language-plaintext highlighter-rouge">EventEmitter</code>, точнее, его метод <code class="language-plaintext highlighter-rouge">emit()</code>. Выглядит это примерно так:</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">eventEmitter</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">EventEmitter</span><span class="p">();</span>

<span class="nx">eventEmitter</span><span class="p">.</span><span class="nf">emit</span><span class="p">(</span><span class="dl">'</span><span class="s1">eventName</span><span class="dl">'</span><span class="p">,</span> <span class="p">...</span><span class="nx">args</span><span class="p">);</span>

</code></pre></div></div> <h3 id="обработка-события">Обработка события</h3> <p>Что такое <code class="language-plaintext highlighter-rouge">eventName</code>, достаточно понятно — это имя ивента, его идентификатор. Но метод <code class="language-plaintext highlighter-rouge">emit()</code> принимает еще и неограниченное количество аргументов, которые он передаст обработчикам этого ивента. Обработчики ивента создаются методом <code class="language-plaintext highlighter-rouge">on()</code>. Смотрите:</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">eventEmitter</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">EventEmitter</span><span class="p">();</span>

<span class="nx">eventEmitter</span><span class="p">.</span><span class="nf">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">eventName</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">вот что произойдет, когда ивент eventName случится</span><span class="dl">'</span><span class="p">);</span>
<span class="p">});</span>

<span class="nx">eventEmitter</span><span class="p">.</span><span class="nf">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">eventName</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">arg1</span><span class="p">,</span> <span class="nx">arg2</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">да, обработчиков у одного ивента может быть несколько, они выполнятся в порядке их объявления</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`этот обработчик принимает еще и два аргумента, arg1 и arg2`</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">arg1</span><span class="p">}</span><span class="s2">, </span><span class="p">${</span><span class="nx">arg2</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span> <span class="c1">// 1, 2</span>
<span class="p">});</span>

<span class="nx">eventEmitter</span><span class="p">.</span><span class="nf">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">eventName</span><span class="dl">'</span><span class="p">,</span> <span class="nf">function </span><span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`a этот обработчик принимает любое количество аргументов`</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">joinedArgs</span> <span class="o">=</span> <span class="nx">args</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="dl">'</span><span class="s1">, </span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="nx">joinedArgs</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span> <span class="c1">// 1, 2, 3, 4, 5</span>
<span class="p">});</span>

<span class="nx">eventEmitter</span><span class="p">.</span><span class="nf">emit</span><span class="p">(</span><span class="dl">'</span><span class="s1">eventName</span><span class="dl">'</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">// создаем событие eventName</span>

</code></pre></div></div> <p>Еще у <code class="language-plaintext highlighter-rouge">EventEmitter</code> есть методы <code class="language-plaintext highlighter-rouge">eventNames()</code> (вернет массив с именами ивентов), <code class="language-plaintext highlighter-rouge">listenerCount(eventName)</code> (отдаст количество обработчиков <code class="language-plaintext highlighter-rouge">eventName</code>) и куча других, менее полезных. За ними — в <a href="https://nodejs.org/api/events.html#class-eventemitter">документацию</a>.</p> <p>Там же можно почитать о наследнике <code class="language-plaintext highlighter-rouge">EventEmitter</code> — <code class="language-plaintext highlighter-rouge">EventEmitterAsyncResource</code>, который то же самое, только с методами <a href="https://nodejs.org/api/async_hooks.html#class-asyncresource">AsyncResource</a>.</p> <h2 id="итоги">Итоги</h2> <p>Статья вышла коротенькой — но что поделать, если про события в JS, как ни странно, много не расскажешь — ничего сложного там нет. Но эту статью можно рассматривать как подготовку к статье о WebSocket — это такой способ двустороннего обмена событиями сервера с клиентом.</p> <p>Будет интересно. Stay tuned!</p>]]></content><author><name></name></author><category term="javascript"/><category term="theory"/><category term="js"/><category term="theory"/><summary type="html"><![CDATA[Статья о cобытийно-ориентированной архитектуре, EventEmitter и вот обо всем об этом.]]></summary></entry><entry><title type="html">Реактивное программирование: теория и практика</title><link href="https://sptm.dev/ru/2023/reactive-programming/" rel="alternate" type="text/html" title="Реактивное программирование: теория и практика"/><published>2023-03-11T21:20:43+00:00</published><updated>2023-03-11T21:20:43+00:00</updated><id>https://sptm.dev/ru/2023/reactive-programming</id><content type="html" xml:base="https://sptm.dev/ru/2023/reactive-programming/"><![CDATA[<h2 id="введение">Введение</h2> <p>Вообще, реактивное программирование — не самая сложная штука. Поэтому я постарался сконцентрироваться на реальном его применении в Node.js, и поэтому здесь будет больше кода, чем текста :)</p> <h3 id="что-такое-реактивное-программирование">Что такое реактивное программирование?</h3> <p>Если по-простому, то реактивное программирование — это парадигма программирования, выстроенная вокруг событий и реагирования на них. Было бы гораздо проще показать примеры реактивного программирования с использованием <a href="https://nodejs.dev/en/learn/the-nodejs-event-emitter/">EventEmitter</a> (о нем у меня тоже будет статья, не сомневайтесь), но мне было интереснее разобраться с такой штукой, как <a href="https://nodejs.org/api/stream.html#stream">Node.js Streams</a>. К тому же, получившийся пример вполне себе применим на практике.</p> <p>Вообще, Streams обычно используются для чтения и записи буферизированных данных (бинарных файлов и всего такого). Но, подумал я, что, если с помощью него работать с API? :)</p> <p>В примере мы читаем данные из настоящего API, получая данные порционно (имитируя пагинацию), и сохраняем их в массив. Понятное дело, что никто не мешает нам их обрабатывать и сохранять в базу, да и вообще делать с ними что угодно.</p> <p>Кому не терпится посмотреть на код, то — <a href="https://github.com/sptmru/reactive-programming-on-streams">вот</a>. Остальных приглашаю разобраться вместе со мной :)</p> <h3 id="api">API</h3> <p>Для того, чтобы продемонстрировать чтение из API стримами, я набросал простенькое API на Fastify. Вот оно:</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">Fastify</span><span class="p">,</span> <span class="p">{</span> <span class="nx">FastifyInstance</span><span class="p">,</span> <span class="nx">RouteShorthandOptions</span><span class="p">,</span> <span class="nx">RouteHandlerMethod</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">fastify</span><span class="dl">'</span>


<span class="kd">const</span> <span class="nx">srv</span><span class="p">:</span> <span class="nx">FastifyInstance</span> <span class="o">=</span> <span class="nc">Fastify</span><span class="p">({})</span>

<span class="kr">interface</span> <span class="nx">Objects</span> <span class="p">{</span>
  <span class="p">[</span><span class="nx">key</span><span class="p">:</span> <span class="kr">string</span><span class="p">]:</span> <span class="kr">number</span><span class="p">,</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">APIResponse</span> <span class="p">{</span>
  <span class="nl">objects</span><span class="p">:</span> <span class="nx">Objects</span><span class="p">,</span>
  <span class="nx">start</span><span class="p">?:</span> <span class="kr">number</span><span class="p">,</span>
  <span class="nx">end</span><span class="p">?:</span> <span class="kr">number</span><span class="p">,</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">RequestQuery</span> <span class="p">{</span>
  <span class="nl">offset</span><span class="p">?:</span> <span class="kr">number</span><span class="p">,</span>
  <span class="nx">limit</span><span class="p">?:</span> <span class="kr">number</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">opts</span><span class="p">:</span> <span class="nx">RouteShorthandOptions</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">schema</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">querystring</span><span class="p">:</span> <span class="p">{</span>
      <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">object</span><span class="dl">'</span><span class="p">,</span>
      <span class="na">properties</span><span class="p">:</span> <span class="p">{</span>
          <span class="na">offset</span><span class="p">:</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">number</span><span class="dl">'</span><span class="p">},</span>
          <span class="na">limit</span><span class="p">:</span> <span class="p">{</span><span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">number</span><span class="dl">'</span><span class="p">}</span>
      <span class="p">},</span>
    <span class="p">}</span>
  <span class="p">},</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">handler</span><span class="p">:</span> <span class="nx">RouteHandlerMethod</span> <span class="o">=</span> <span class="k">async </span><span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">_res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="na">response</span><span class="p">:</span> <span class="nx">APIResponse</span> <span class="o">=</span> <span class="p">{</span>
      <span class="na">objects</span><span class="p">:</span> <span class="p">{}</span>
  <span class="p">};</span>

  <span class="kd">const</span> <span class="nx">query</span> <span class="o">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">query</span> <span class="kd">as </span><span class="nx">RequestQuery</span><span class="p">;</span>

  <span class="kd">const</span> <span class="nx">offset</span> <span class="o">=</span> <span class="nc">Number</span><span class="p">(</span><span class="nx">query</span><span class="p">?.</span><span class="nx">offset</span><span class="p">)</span> <span class="o">||</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">limit</span>  <span class="o">=</span> <span class="nc">Number</span><span class="p">(</span><span class="nx">query</span><span class="p">?.</span><span class="nx">limit</span><span class="p">)</span> <span class="o">||</span> <span class="mi">50</span><span class="p">;</span>

  <span class="kd">const</span> <span class="nx">finalNum</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>

  <span class="kd">const</span> <span class="nx">end</span> <span class="o">=</span> <span class="p">(</span><span class="nc">Number</span><span class="p">(</span><span class="nx">offset</span><span class="p">)</span> <span class="o">+</span> <span class="nc">Number</span><span class="p">(</span><span class="nx">limit</span><span class="p">))</span> <span class="o">&lt;</span> <span class="nx">finalNum</span>
    <span class="p">?</span> <span class="p">(</span><span class="nc">Number</span><span class="p">(</span><span class="nx">offset</span><span class="p">)</span> <span class="o">+</span> <span class="nc">Number</span><span class="p">(</span><span class="nx">limit</span><span class="p">))</span>
    <span class="p">:</span> <span class="nx">finalNum</span><span class="p">;</span>

    <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">offset</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">end</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">response</span><span class="p">.</span><span class="nx">objects</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">i</span><span class="p">;</span>
    <span class="p">}</span>

  <span class="nx">response</span><span class="p">.</span><span class="nx">start</span> <span class="o">=</span> <span class="nx">offset</span><span class="p">;</span>
  <span class="nx">response</span><span class="p">.</span><span class="nx">end</span> <span class="o">=</span> <span class="nx">end</span><span class="p">;</span>

  <span class="k">return</span> <span class="nx">response</span><span class="p">;</span>
<span class="p">};</span>

<span class="nx">srv</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">/</span><span class="dl">'</span><span class="p">,</span> <span class="nx">opts</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">start</span> <span class="o">=</span>  <span class="k">async </span><span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="k">await</span> <span class="nx">srv</span><span class="p">.</span><span class="nf">listen</span><span class="p">({</span> <span class="na">port</span><span class="p">:</span> <span class="mi">3000</span> <span class="p">});</span>
  <span class="p">}</span> <span class="k">catch </span><span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">srv</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nf">error</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
    <span class="nx">process</span><span class="p">.</span><span class="nf">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nf">start</span><span class="p">();</span>
</code></pre></div></div> <p>Как мы видим, оно включает в себя всего один эндпойнт, который может отдать объекты вида <code class="language-plaintext highlighter-rouge">[key: string]: number</code> и поддерживает пагинацию (то есть, мы можем указать, с какого и по какое число нам сгенерировать объекты). Есть и лимит: числа больше <code class="language-plaintext highlighter-rouge">10000</code> он не отдаст (сделано это для того, чтобы чтение из API всегда было конечно). Все, больше ничего интересного: все самое интересное — в клиенте.</p> <h3 id="клиент">Клиент</h3> <p>Клиент основан на Node.js-стримах и содержит два класса, наследующихся от <a href="https://nodejs.org/api/stream.html#class-streamreadable">Readable</a> и <a href="https://nodejs.org/api/stream.html#class-streamwritable">Writable</a> соответственно. Тот, что <code class="language-plaintext highlighter-rouge">Readable</code>, порционно читает данные из API, соблюдая пагинацию — а тот, что <code class="language-plaintext highlighter-rouge">Writable</code>, эти данные так же порционнно собирает в массив.</p> <p>Это немного напоминает очереди сообщений, о которых тоже будет статья. Давайте смотреть код:</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">Writable</span><span class="p">,</span> <span class="nx">Readable</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">node:stream</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">dbArr</span><span class="p">:</span> <span class="nx">object</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>

<span class="kr">interface</span> <span class="nx">Objects</span> <span class="p">{</span>
    <span class="p">[</span><span class="nx">key</span><span class="p">:</span> <span class="kr">string</span><span class="p">]:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">APIResponse</span> <span class="p">{</span>
    <span class="nl">start</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span>
    <span class="nx">end</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span>
    <span class="nx">objects</span><span class="p">:</span> <span class="nx">Objects</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">ApiReadable</span> <span class="kd">extends</span> <span class="nc">Readable</span> <span class="p">{</span>

    <span class="k">private</span> <span class="nx">uri</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="k">private</span> <span class="nx">offset</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="k">private</span> <span class="nx">limit</span><span class="p">:</span> <span class="kr">number</span>

    <span class="nf">constructor</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="p">({</span> <span class="na">objectMode</span><span class="p">:</span> <span class="kc">true</span> <span class="p">});</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">uri</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">http://localhost:3000/</span><span class="dl">'</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">limit</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">async</span> <span class="nf">getAPI</span><span class="p">():</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">APIResponse</span><span class="o">|</span><span class="kc">null</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="k">await</span> <span class="nf">fetch</span><span class="p">(</span><span class="s2">`</span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">uri</span><span class="p">}</span><span class="s2">?limit=</span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">limit</span><span class="p">}</span><span class="s2">&amp;offset=</span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">offset</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">response</span><span class="p">.</span><span class="nf">json</span><span class="p">();</span>

        <span class="c1">// кончились данные в API? Вернем null;</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">result</span><span class="p">?.</span><span class="nx">end</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">end</span> <span class="o">-</span> <span class="nx">result</span><span class="p">.</span><span class="nx">start</span><span class="p">)</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">limit</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// вернем ответ API в виде JSON</span>
        <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// переопределим встроенный в Readable метод _read</span>
    <span class="nx">override</span> <span class="k">async</span> <span class="nf">_read</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// заберем нужное количество данных из API</span>
        <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nf">getAPI</span><span class="p">();</span>

        <span class="c1">// если данных нет, отдадим null во Writable — это сгенерит событие end</span>
        <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// а если данные есть, пихнем их во Writable</span>
            <span class="k">this</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">objects</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// сместим пагинацию вперед</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">offset</span> <span class="o">=</span> <span class="nx">result</span><span class="p">.</span><span class="nx">end</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">offset</span> <span class="p">?</span> <span class="nx">result</span><span class="p">.</span><span class="nx">end</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="nx">result</span><span class="p">.</span><span class="nx">end</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">ObjWritable</span> <span class="kd">extends</span> <span class="nc">Writable</span> <span class="p">{</span>

    <span class="k">private</span> <span class="nx">dbArr</span><span class="p">:</span> <span class="nx">object</span><span class="p">[];</span>

    <span class="c1">// конструктор принимает архив, в который будем пихать данные, полученные от Readable</span>
    <span class="nf">constructor</span><span class="p">(</span><span class="nx">dbArr</span><span class="p">:</span> <span class="nx">object</span><span class="p">[])</span> <span class="p">{</span>
        <span class="k">super</span><span class="p">({</span> <span class="na">highWaterMark</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="na">objectMode</span><span class="p">:</span> <span class="kc">true</span> <span class="p">});</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">dbArr</span> <span class="o">=</span> <span class="nx">dbArr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nf">writeToObj</span><span class="p">(</span><span class="nx">chunk</span><span class="p">:</span> <span class="nx">object</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">dbArr</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">chunk</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// переопределим метод Writable.prototype._write - теперь он пишет в наш массив полученные данные и исполняет свой дефолтный коллбек</span>
    <span class="nx">override</span> <span class="nf">_write</span><span class="p">(</span><span class="nx">chunk</span><span class="p">:</span> <span class="nx">object</span><span class="p">,</span> <span class="nx">_encoding</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">callback</span><span class="p">:</span> <span class="nb">Function</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nf">writeToObj</span><span class="p">(</span><span class="nx">chunk</span><span class="p">);</span>
        <span class="nf">callback</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// то же самое произойдет и с дефолтным методом _writev, который пишет несколько кусков (chunks) данных за раз</span>
    <span class="nx">override</span> <span class="nf">_writev</span><span class="p">(</span><span class="nx">chunks</span><span class="p">:</span> <span class="nx">object</span><span class="p">[],</span> <span class="nx">callback</span><span class="p">:</span> <span class="nb">Function</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">dbArr</span><span class="p">.</span><span class="nf">push</span><span class="p">(...</span><span class="nx">chunks</span><span class="p">);</span>
        <span class="nf">callback</span><span class="p">();</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="c1">// создадим экземпляры наших классов</span>
<span class="kd">const</span> <span class="nx">objWritable</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ObjWritable</span><span class="p">(</span><span class="nx">dbArr</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">apiReadable</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ApiReadable</span><span class="p">();</span>

<span class="nx">apiReadable</span><span class="p">.</span><span class="nf">pipe</span><span class="p">(</span><span class="nx">objWritable</span><span class="p">);</span> <span class="c1">// и самое интересное: подпишем Writable на Readable</span>
<span class="nx">apiReadable</span><span class="p">.</span><span class="nf">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">end</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="nx">dbArr</span><span class="p">));</span>
</code></pre></div></div> <p>С комментами понятнее? Да, там внутри EventEmitter :) но как красиво! Забираем данные из API порционнно, порционно их куда угодно пишем. Обратите внимание на параметр <code class="language-plaintext highlighter-rouge">highWaterMark</code> у <code class="language-plaintext highlighter-rouge">Writable</code> — это количество одновременно хранимых данных. Так можно и rate limiting безо всяких брокеров сообщений соорудить :)</p> <p>В общем, мне кажется, это отличный и небанальный пример реактивного программирования на Node.js.</p> <h2 id="выводы">Выводы</h2> <p>Вообще, JavaScript и на фронте, и на бэке прекрасно подходит для реализации event-driven архитектуры. И реактивное программирование может быть не какой-то далекой от реальной разработки теорией, а вполне себе применимой штукой.</p> <p>Stay tuned! Хоть блог и для новичков по большей части, но иногда я буду писать и что-то повеселее :)</p>]]></content><author><name></name></author><category term="javascript"/><category term="mq"/><category term="theory"/><category term="js"/><category term="mq"/><category term="theory"/><summary type="html"><![CDATA[Статья о реактивном программировании с примерами на Node.js Streams.]]></summary></entry><entry><title type="html">Функциональное программирование. Что это и зачем?</title><link href="https://sptm.dev/ru/2023/functional-programming/" rel="alternate" type="text/html" title="Функциональное программирование. Что это и зачем?"/><published>2023-03-10T02:40:43+00:00</published><updated>2023-03-10T02:40:43+00:00</updated><id>https://sptm.dev/ru/2023/functional-programming</id><content type="html" xml:base="https://sptm.dev/ru/2023/functional-programming/"><![CDATA[<h2 id="введение">Введение</h2> <p>Сразу уточню: функциональное программирование — это не когда добренько так в один файл функций навалили и радуемся. И вообще: сам факт использования функций не делает программирование функциональным.</p> <p>Тогда что ж это такое? Это такой вид программирования, в котором функции понимают в математическом смысле, как отображение одного множества в другое. Или проще: функция — это правило, по которому каждому элементу множества 1 соответствует один и только один элемент множества 2.</p> <p>Наверняка вы уже слышали понятие “чистая функция”? Вот это оно. Исключительно вычисления, без побочных эффектов, если передашь значение 1 — всегда получишь одно и то же значение 2. Очевидно, что их легко тестировать и кэшировать. Но об этом — позже.</p> <h2 id="взгляд-с-другой-стороны">Взгляд с другой стороны</h2> <p>Функциональное программирование противоположно императивному — тому, к которому мы привыкли, тому, которое представляет собой последовательность инструкций, выполняемых одна за другой. Функциональное программирование часто считают подвидом программирования декларативного, того, где мы описываем, что мы хотим получить, но не описывая, как. Хороший пример декларативного программирования — язык SQL:</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">book</span><span class="p">.</span><span class="n">title</span> <span class="k">as</span> <span class="n">title</span><span class="p">,</span> <span class="n">book</span><span class="p">.</span><span class="nb">year</span> <span class="k">as</span> <span class="nb">year</span>
<span class="k">FROM</span> <span class="n">author</span>
<span class="k">JOIN</span> <span class="n">book</span> <span class="k">ON</span> <span class="n">book</span><span class="p">.</span><span class="n">author_id</span> <span class="o">=</span> <span class="n">author</span><span class="p">.</span><span class="n">id</span>
<span class="k">WHERE</span> <span class="n">author</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="nv">"Eric A. Blair"</span> <span class="k">AND</span> <span class="nb">year</span> <span class="o">&gt;=</span> <span class="mi">1945</span> <span class="k">AND</span> <span class="nb">year</span> <span class="o">&lt;=</span> <span class="mi">1949</span>

<span class="o">|</span> <span class="n">title</span>       <span class="o">|</span> <span class="nb">year</span> <span class="o">|</span>
<span class="o">|</span><span class="c1">-------------|------|</span>
<span class="o">|</span> <span class="mi">1984</span>        <span class="o">|</span> <span class="mi">1949</span> <span class="o">|</span>
<span class="o">|</span> <span class="n">Animal</span> <span class="n">Farm</span> <span class="o">|</span> <span class="mi">1945</span> <span class="o">|</span>
<span class="o">|</span>             <span class="o">|</span>      <span class="o">|</span>
</code></pre></div></div> <p>Видите? Мы не описываем, как достать книги из базы, мы просто описываем, что хотим получить: заголовки и года выпуска книг автора Eric A. Blair, выпущенных с 1945 по 1949 год включительно. В функциональном программировании мы часто делаем так же.</p> <h2 id="принципы-функционального-программирования">Принципы функционального программирования</h2> <h3 id="последовательность-не-имеет-значения">Последовательность не имеет значения</h3> <p>Нет разницы, в каком порядке мы напишем подпрограммы; они применятся тогда, когда будет нужно, а не в порядке их написания.</p> <h3 id="нет-переменных">Нет переменных</h3> <p>Точнее, есть, но не в том виде, в котором мы привыкли их видеть. Мы можем объявлять константы, а промежуточные значения хранятся в функциях.</p> <h3 id="чистые-функции">Чистые функции</h3> <p>А почему мы храним промежуточные значения в функциях? А потому что они чистые — всегда вернут один и тот же результат B для параметра А.</p> <h2 id="концепции">Концепции</h2> <h3 id="функции-высших-порядков">Функции высших порядков</h3> <p>Функции высших порядков — это такие функции, которые могут принимать другие функции в качестве аргументов и возвращать функции как результат выполнения. Такое есть и активно используется в JS:</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="kd">const</span> <span class="nx">plusOne</span> <span class="o">=</span> <span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">arr2</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="nx">plusOne</span><span class="p">)</span> <span class="c1">// [2, 3, 4]</span>
</code></pre></div></div> <p>Видели? Мы передали в функцию map функцию plusOne (кстати, саму функцию <code class="language-plaintext highlighter-rouge">map()</code> можно рассматривать как <a href="https://sptm.dev/ru/2023/monads-in.js/">монаду</a> — а монады тоже очень характерны для ФП).</p> <p>Еше один пример:</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">sum</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span> <span class="o">+</span> <span class="nx">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nf">curry</span> <span class="p">(</span><span class="nx">func</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">function</span> <span class="nf">curried</span><span class="p">(...</span><span class="nx">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if </span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;=</span> <span class="nx">func</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">func</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">args</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="kd">function</span><span class="p">(...</span><span class="nx">args2</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nx">curried</span><span class="p">.</span><span class="nf">apply</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="nx">args</span><span class="p">.</span><span class="nf">concat</span><span class="p">(</span><span class="nx">args2</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">curriedSummer</span> <span class="o">=</span> <span class="nf">curry</span><span class="p">(</span><span class="nx">sum</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">curriedSummer</span><span class="p">)</span> <span class="c1">//function</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nf">curriedSummer</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="c1">// function)</span>
<span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nf">curriedSummer</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="mi">2</span><span class="p">))</span> <span class="c1">// function)</span>
</code></pre></div></div> <p>Как мы видим из этого примера, функции в JS могут возвращать функции — из чего, кстати, мы можем сделать вывод, что JS поддерживает функции высших порядков. Кстати — это еще и пример каррирования функций, еще одного характерного для функционального программирования приемов, поддерживаенмых JS. О каррировании можно подробнее почитать <a href="https://sptm.dev/ru/2023/execution-context-in-js/">здесь</a>.</p> <h3 id="рекурсия">Рекурсия</h3> <p>В функциональных языках программирования циклы обычно представленны в виде рекурсии. А в строгих языках программирования циклов и вовсе нет. Рекурсивные функции вызывают сами себя, пока не достигнут результата. Для этого может потребоваться большой стек, но такая оптимизация, как хвостовая рекурсия, помогает этого избежать</p> <p>Хвостовая рекурсия — это такая рекурсия, при которой рекурсивный вызов является последней операцией перед возвратом из функции. Такую рекурсию компилятор может заменить на итерацию, и это поможет избежать переполнения стека.</p> <p>Начиная с ES6, JavaScript поддерживает хвостовую рекурсию (только в strict mode). Вот такой пример будет преобразован компилятором V8 в итерацию:</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">"</span><span class="s2">use strict</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">function</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">acc</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if </span><span class="p">(</span><span class="nx">x</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">acc</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nf">foo</span><span class="p">(</span><span class="nx">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">acc</span> <span class="o">*</span> <span class="nx">x</span><span class="p">);</span>
<span class="p">}</span>
<span class="nf">foo</span><span class="p">(</span><span class="mi">100000</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div></div> <h2 id="особенности-функционального-программирования">Особенности функционального программирования</h2> <p>Основная особенность функционального программирования — то, что в процессе выполнения она не имеет состояния. В императивных языках есть значения переменных, результаты побочных эффектов — всего этого в ФП нет. Следствием этого является то, что функциональная программа в чистом виде не может изменять уже имеющиеся у нее данные, будучи вынуждена порождать новые путем копирования или расширения старых. Следствием того же является использование рекурсии вместо циклов.</p> <h3 id="сильные-стороны">Сильные стороны</h3> <h4 id="надежность">Надежность</h4> <p>Программа без состояния максимально надежна, да и данные меняться не могут.</p> <h4 id="удобство-юнит-тестирования">Удобство юнит-тестирования</h4> <p>Писать юнит-тесты для чистых функций — одно удовольствие, ведь нам не придется имитировать побочные эффекты (мокать работу с БД, файловой системой и так далее).</p> <h4 id="параллельные-вычисления">Параллельные вычисления</h4> <p>Если все функции не содержат побочных эффектов, почему бы не выполнять их параллельно?</p> <h3 id="недостатки">Недостатки</h3> <p>По сути, недостатки функционального программирования следуют из его же особенностей. К примеру, если мы не можем изменять данные, то вынуждены постоянно аллоцировать новую память, и нам крайне важен эффективный сборщик мусора (как сборка мусора устроена в JS, можно почитать <a href="https://sptm.dev/ru/2023/memory-management-in-js/">здесь</a>). А нестрогая модель вычислений создает проблемы с операциями ввода/вывода, где порядок исполнения кода важен (это решается с помощью <a href="https://sptm.dev/ru/2023/monads-in.js/">монад</a>).</p> <h2 id="выводы">Выводы</h2> <p>Функциональная парадигма как минимум неплохо расширяет кругозор, и во многих случаях гораздо эффективнее имреративной. Раз уж мы тут JS изучаем, то нужно сказать, что JS поддерживает очень многое из ФП: <a href="https://sptm.dev/ru/2023/monads-in.js/">монады</a>, <a href="https://sptm.dev/ru/2023/execution-context-in-js/">функции/классы высшего порядка</a> и каррирование, хвостовую рекурсию. Чистые функции тоже никто писать не запрещает. Поэтому на JS вполне можно писать в функциональном стиле :)</p> <p>Stay tuned! Статей будет еще очень много :)</p>]]></content><author><name></name></author><category term="javascript"/><category term="theory"/><category term="js"/><category term="theory"/><summary type="html"><![CDATA[Статья о функциональном программировании, его преимуществах и некоторых его подвидах.]]></summary></entry><entry><title type="html">Как и зачем писать тесты?</title><link href="https://sptm.dev/ru/2023/application-testing/" rel="alternate" type="text/html" title="Как и зачем писать тесты?"/><published>2023-03-10T02:40:43+00:00</published><updated>2023-03-10T02:40:43+00:00</updated><id>https://sptm.dev/ru/2023/application-testing</id><content type="html" xml:base="https://sptm.dev/ru/2023/application-testing/"><![CDATA[<h2 id="введение">Введение</h2> <p>Начну с конца: приложения нужно тестировать. Точка. А теперь можно и разобраться, как и зачем нам это делать.</p> <p>Насчет той части, что про “зачем”, можно и коротко:</p> <ul> <li>чтобы убедиться, что приложение работает так, как задумано</li> <li>чтобы отловить ошибку после внесения изменений в код и до того, как код достигнет продакшна</li> <li>чтобы зафиксировать идеальное состояние системы — так проще вносить изменения</li> </ul> <p>А по поводу “как” — мы начнем с самого очевидного и самого далекого от разработчиков вида тестирования — тестирования приложения вручную.</p> <h3 id="ручное-тестирование">Ручное тестирование</h3> <p>Да, приложения тестируют в том числе вручную — руками проверяя все возможные сценарии использования приложения, чтобы удостовериться, что все работает так, как задумано. Вообще, этим занимаются QA-инженеры, но и программистам порой приходится это делать.</p> <p>Хорошей практикой считается вручную протестить фичу, которую вы написали или баг, который пофиксили. Облегчите работу QA-специалистам, протестируйте то, что написали, прежде чем отдавать код на ревью. В некоторых компаниях такое тестирование даже входит в процесс код-ревью.</p> <p>Но в целом — статья не об этом, а о разных видах автоматизированного тестирования. Начнем снова с конца: со сквозного тестирования.</p> <h3 id="сквозное-e2e-тестирование">Сквозное (E2E) тестирование</h3> <p>Этот подвид автоматизированного тестирования тоже чаще всего берут на себя QA-инженеры. Суть его в том, чтобы полностью эмулировать пользовательскую среду и сымитировать всевозможные пользовательские сценарии автоматически, проверяя, все ли идет так, как должно. Тестирование одновременно и очень полезное — легко отловить ошибку, и очень неточное — даже отловив ошибку, мы не получим никакой информации о том, где именно ошибка произошла.</p> <p>Для того, чтобы сузить пространство поиска ошибок, существуют другие виды тестов.</p> <h3 id="контрактное-тестирование-тестирование-api-эндпойнтов">Контрактное тестирование (тестирование API-эндпойнтов)</h3> <p>Этот подвид автоматизированного тестирования проверяет, правильно ли работает API. В самом простом случае такое тестирование сводится к запросу к эндпойнту и сравнению ответа с образцом.</p> <p>Минус такого подхода - оно гарантирует лишь то, что API правильно ответит на запрос. К примеру, мы тестируем POST-эндпойнт, создающий некую сущность в системе. Мы пробуем неправильный запрос — и получаем HTTP 400 Bad Request. Мы отправляем правильно сформированный POST-запрос и получаем HTTP 201 Created. Выглядит так, что все работает отлично, правда? Но на самом деле мы убедились лишь в том, что эндпойнт правильно отреагирует на корректность запроса. Создалась ли сущность в системе после отправки корректного запроса? Мы не знвем.</p> <p>Есть возможность усовершенствовать этот вид тестирования: помимо проверки ответа API, мы можем сходить в базу и удостовериться, что сущность была создана (удалена, изменена и так далее, зависит от запроса). Такое тестирование дает нам возможность гарантировать правильную работу API, но, во-первых, по сложности приближается к E2E-тестированию, а во-вторых, все еще не очень точно указывает на место, где случилась ошибка, если она случилась.</p> <p>Для того, чтобы еще ближе приблизиться к месту возникновения ошибки и еще сильнее зафиксировать идеальное состояние системы, существует еще пара видов тестирования, о которых мы поговорим ниже.</p> <h3 id="модульное-юнит-тестирование">Модульное (юнит-тестирование)</h3> <p>Юнит-тестирование — это тестирование самой маленькой части приложения. Обычно это класс, содержащий методы — и вот методы мы и облагаем юнит-тестами. Неоспоримое преимущество такого вида тестирования — если тест падает, мы точно знаем, где именно у нас ошибка. Но с этим тестированием тоже есть проблемка. И заключается она в том, что далеко не всегда наши методы — это чистые функции (об этом подробнее можно почитать в <a href="https://sptm.dev/ru/2023/functional-programming/">статье о функциональном программировании</a>), и часто они имеют побочные эффекты — вроде обращений к базе данных, внешнему сервису или файловой системе.</p> <p>Такие обращения принято имитировать (мокать), ведь мы тестируем бизнес-логику, а не слой данных и взаимодействия с внешними сервисами. Для этого мы пишем моки (имитации исходящих взаимодействий) или стабы (имитации входящих взаимодействий) и пробрасываем их в тестируемые методы. Для этого код должен поддерживать <a href="https://sptm.dev/ru/2023/dependency-injection/">инверсию зависимостей</a> и в целом соответствовать <a href="https://sptm.dev/ru/2023/solid-grasp-and-stuff/">правильным практикам написания кода</a>.</p> <p>Поскольку так происходит не всегда (к сожалению), нам приходится прибегать к интеграционным тестам.</p> <h3 id="интеграционное-тестирование">Интеграционное тестирование</h3> <p>В общем и целом, все то, что похоже на юнит-тесты, но:</p> <ul> <li>захватывает большую часть приложения, чем отдельные методы</li> <li>не использует моки/стабы, проверяя интеграции с БД / файловой системой / внешними сервисами</li> </ul> <p>— и называется интеграционными тестами. Этот вид тестирования необходим для проверки взаимодействия разных частей приложения (и поэтому становится очень важным для приложений, построенных с использованием <a href="https://sptm.dev/ru/2023/microservices-vs-monolith/">микросервисной архитектуры</a>).</p> <p>А еще он нередко спасает тогда, когда текущее состояние системы нужно зафиксировать (к примеру, перед масштабным рефакторингом), а качество кода не позволяет обойтись юнит-тестами.</p> <h2 id="выводы">Выводы</h2> <p>Тесты — нужны. Вот вам и выводы :)</p> <p>А если серьезно, то у каждого вида тестирования есть и плюсы, и минусы. Соблюдайте баланс (тут можно обратиться к <a href="https://tlroadmap.io/roles/technical-lead/product-quality/testing/test-pyramid.html">пирамиде тестирования</a>), и будет вам счастье :)</p>]]></content><author><name></name></author><category term="javascript"/><category term="theory"/><category term="js"/><category term="theory"/><summary type="html"><![CDATA[Статья о тестировании наших приложений, его видах, преимуществах и недостатках каждого.]]></summary></entry><entry><title type="html">Профилирование Node.js-приложений</title><link href="https://sptm.dev/ru/2023/profiling-nodejs-app/" rel="alternate" type="text/html" title="Профилирование Node.js-приложений"/><published>2023-03-09T14:40:43+00:00</published><updated>2023-03-09T14:40:43+00:00</updated><id>https://sptm.dev/ru/2023/profiling-nodejs-app</id><content type="html" xml:base="https://sptm.dev/ru/2023/profiling-nodejs-app/"><![CDATA[<h2 id="с-чего-начнем">С чего начнем?</h2> <p>Иногда нам сложно понять, какого черта приложение работает медленно, хотя не должно. А иногда оно вроде бы и работает ОК, но нужно, чтобы оно работало быстрее. Можно, конечно, долго и вдумчиво читать код, рандомно что-то менять, замерять скорость и надеяться только на себя.</p> <p>К счастью, в Node.js встроен помощник на такие случаи — профайлер. Точнее, он встроен в V8 (что это такое, можно почитать <a href="https://sptm.dev/ru/2023/asynchrony-in-js/">здесь</a> или даже <a href="https://v8.dev">здесь</a>). Профайлер V8 — это такая штука, которая делит стек выполняющейся программы (о стеке можно почитать <a href="https://sptm.dev/ru/2023/memory-management-in-js/">в моей статье об управлении памятью в JS</a>) на фрагменты через равные промежутки времени. А представляет он нам результаты этих фрагментов с учетом оптимизаций (к примеру, JIT-компиляции) в виде ряда тиков. Примерно вот так:</p> <pre><code class="language-csv">code-creation,LazyCompile,0,0x2d5000a337a0,396,"bp native array.js:1153:16",0x289f644df68,~
code-creation,LazyCompile,0,0x2d5000a33940,716,"hasOwnProperty native v8natives.js:198:30",0x289f64438d0,~
code-creation,LazyCompile,0,0x2d5000a33c20,284,"ToName native runtime.js:549:16",0x289f643bb28,~
code-creation,Stub,2,0x2d5000a33d40,182,"DoubleToIStub"
code-creation,Stub,2,0x2d5000a33e00,507,"NumberToStringStub"
</code></pre> <p>Не очень понятно, правда? В прошлом пришлось бы отдельно собрать V8, чтобы иметь возможность анализировать эти тики. Но, к счастью, в 2016 году у Node.js появились опции <code class="language-plaintext highlighter-rouge">--prof</code> и <code class="language-plaintext highlighter-rouge">--prof-process</code>, которые позволяют делать это сильно проще.</p> <p>Давайте представим, что пишем сверх-хайлоад-микросервис по созданию и аутентификации пользователей на Express, а потом отпрофилируем его, чтобы понять, как его можно ускорить.</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">express</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">express</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">crypto</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">crypto</span><span class="dl">'</span><span class="p">;</span>


<span class="kd">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="nf">express</span><span class="p">();</span>
<span class="kd">const</span> <span class="nx">users</span> <span class="o">=</span> <span class="p">[];</span>


<span class="nx">app</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">/newUser</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">username</span> <span class="o">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">query</span><span class="p">.</span><span class="nx">username</span> <span class="o">||</span> <span class="dl">''</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">password</span> <span class="o">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">query</span><span class="p">.</span><span class="nx">password</span> <span class="o">||</span> <span class="dl">''</span><span class="p">;</span>

    <span class="nx">username</span> <span class="o">=</span> <span class="nx">username</span><span class="p">.</span><span class="nf">replace</span><span class="p">(</span><span class="sr">/</span><span class="se">[</span><span class="sr">!@#$%^&amp;*</span><span class="se">]</span><span class="sr">/g</span><span class="p">,</span> <span class="dl">''</span><span class="p">);</span>

    <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">username</span> <span class="o">||</span> <span class="o">!</span><span class="nx">password</span> <span class="o">||</span> <span class="nx">users</span><span class="p">[</span><span class="nx">username</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nf">sendStatus</span><span class="p">(</span><span class="mi">400</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">const</span> <span class="nx">salt</span> <span class="o">=</span> <span class="nx">crypto</span><span class="p">.</span><span class="nf">randomBytes</span><span class="p">(</span><span class="mi">128</span><span class="p">).</span><span class="nf">toString</span><span class="p">(</span><span class="dl">'</span><span class="s1">base64</span><span class="dl">'</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">hash</span> <span class="o">=</span> <span class="nx">crypto</span><span class="p">.</span><span class="nf">pbkdf2Sync</span><span class="p">(</span><span class="nx">password</span><span class="p">,</span> <span class="nx">salt</span><span class="p">,</span> <span class="mi">10000</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="dl">'</span><span class="s1">sha512</span><span class="dl">'</span><span class="p">);</span>

    <span class="nx">users</span><span class="p">[</span><span class="nx">username</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">salt</span><span class="p">,</span> <span class="nx">hash</span> <span class="p">};</span>

    <span class="nx">res</span><span class="p">.</span><span class="nf">sendStatus</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
<span class="p">});</span>


<span class="nx">app</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">/auth</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">username</span> <span class="o">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">query</span><span class="p">.</span><span class="nx">username</span> <span class="o">||</span> <span class="dl">''</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">password</span> <span class="o">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">query</span><span class="p">.</span><span class="nx">password</span> <span class="o">||</span> <span class="dl">''</span><span class="p">;</span>

    <span class="nx">username</span> <span class="o">=</span> <span class="nx">username</span><span class="p">.</span><span class="nf">replace</span><span class="p">(</span><span class="sr">/</span><span class="se">[</span><span class="sr">!@#$%^&amp;*</span><span class="se">]</span><span class="sr">/g</span><span class="p">,</span> <span class="dl">''</span><span class="p">);</span>

    <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">username</span> <span class="o">||</span> <span class="o">!</span><span class="nx">password</span> <span class="o">||</span> <span class="o">!</span><span class="nx">users</span><span class="p">[</span><span class="nx">username</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nf">sendStatus</span><span class="p">(</span><span class="mi">400</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">const</span> <span class="p">{</span> <span class="nx">salt</span><span class="p">,</span> <span class="nx">hash</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">users</span><span class="p">[</span><span class="nx">username</span><span class="p">];</span>
    <span class="kd">const</span> <span class="nx">encryptHash</span> <span class="o">=</span> <span class="nx">crypto</span><span class="p">.</span><span class="nf">pbkdf2Sync</span><span class="p">(</span><span class="nx">password</span><span class="p">,</span> <span class="nx">salt</span><span class="p">,</span> <span class="mi">10000</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="dl">'</span><span class="s1">sha512</span><span class="dl">'</span><span class="p">);</span>

    <span class="k">if </span><span class="p">(</span><span class="nx">crypto</span><span class="p">.</span><span class="nf">timingSafeEqual</span><span class="p">(</span><span class="nx">hash</span><span class="p">,</span> <span class="nx">encryptHash</span><span class="p">))</span> <span class="p">{</span>
        <span class="nx">res</span><span class="p">.</span><span class="nf">sendStatus</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">res</span><span class="p">.</span><span class="nf">sendStatus</span><span class="p">(</span><span class="mi">401</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">});</span>



<span class="nx">app</span><span class="p">.</span><span class="nf">listen</span><span class="p">(</span><span class="mi">3000</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">Example app listening on port 3000</span><span class="dl">'</span><span class="p">)</span>
<span class="p">});</span>
</code></pre></div></div> <h2 id="профилирование">Профилирование</h2> <p>Вот мы написали приложение, выкатили, а пользователи жалуются, что все медленно. Мы запустим приложение с опцией <code class="language-plaintext highlighter-rouge">--prof</code> и сымитируем нагрузку на приложение с помощью <a href="https://httpd.apache.org/docs/2.4/programs/ab.html">ApacheBench</a>:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>node <span class="nt">--prof</span> express-app.js <span class="c"># запускаем приложение с опцией --prof</span>

<span class="c"># создаем пользователя</span>
curl <span class="nt">-X</span> GET <span class="s2">"http://localhost:3000/newUser?username=user&amp;password=password"</span>

<span class="c"># имитируем множество авторизаций</span>
ab <span class="nt">-k</span> <span class="nt">-c</span> 20 <span class="nt">-n</span> 250 <span class="s2">"http://localhost:3000/auth?username=user&amp;password=password"</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># получаем такой результат:

Concurrency Level:      20
Time taken for tests:   6.620 seconds
Complete requests:      250
Failed requests:        0
Keep-Alive requests:    250
Total transferred:      57250 bytes
HTML transferred:       500 bytes
Requests per second:    37.77 [#/sec] (mean)
Time per request:       529.579 [ms] (mean)
Time per request:       26.479 [ms] (mean, across all concurrent requests)
Transfer rate:          8.45 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:        0    1   2.0      0       9
Processing:    29  506 129.5    502    1038
Waiting:       29  506 129.6    502    1038
Total:         29  507 128.8    502    1038

Percentage of the requests served within a certain time (ms)
  50%    502
  66%    503
  75%    507
  80%    529
  90%    535
  95%    551
  98%   1001
  99%   1005
 100%   1038 (longest request)
</code></pre></div></div> <p>Получаем, что наше приложение может обработать только 37.77 запросов в секунду, и запрос в среднем занимает около полусекунды, что не очень-то для хайлоад-приложения. Поскольку мы запустили наше приложение с опцией <code class="language-plaintext highlighter-rouge">--prof</code>, в каталоге с приложением появится файл вида <code class="language-plaintext highlighter-rouge">isolate-0x&lt;много цифр&gt;-v8.log</code>. Разберемся в этом файле с помощью тикового процессора, встроенного в Node.js (флаг <code class="language-plaintext highlighter-rouge">--prof-process</code>):</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>node <span class="nt">--prof-process</span> isolate-0xnnnnnnnnnnnn-v8.log <span class="o">&gt;</span> processed.txt
</code></pre></div></div> <p>Откроем файл <code class="language-plaintext highlighter-rouge">processed.txt</code>, увидим кучу секций, разбитых по языкам. Глянем в Summary:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Summary]:
   ticks  total  nonlib   name
     11    0.2%    0.2%  JavaScript
   5454   99.1%   99.7%  C++
     18    0.3%    0.3%  GC
     36    0.7%          Shared libraries
      4    0.1%          Unaccounted
</code></pre></div></div> <p>Целых 99 с чем-то процентов заняли задачи, выполняемые C++. Выглядит не очень и само по себе, но посмотрим в раздел C++, чтобы понять, какие функции заняли больше процессорного времени:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[C++]:
   ticks  total  nonlib   name
   5357   97.3%   98.0%  T node::contextify::ContextifyScript::~ContextifyScript()
     42    0.8%    0.8%  T node::builtins::BuiltinLoader::CompileFunction(v8::FunctionCallbackInfo&lt;v8::Value&gt; const&amp;)
     20    0.4%    0.4%  T node::contextify::ContextifyContext::CompileFunction(v8::FunctionCallbackInfo&lt;v8::Value&gt; const&amp;)
     16    0.3%    0.3%  T _semaphore_destroy
      9    0.2%    0.2%  T _posix_spawnattr_setmacpolicyinfo_np
      3    0.1%    0.1%  t std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp; std::__1::__put_character_sequence&lt;char, std::__1::char_traits&lt;char&gt; &gt;(std::__1::basic_ostream&lt;char, std::__1::char_traits&lt;char&gt; &gt;&amp;, char const*, unsigned long)
      2    0.0%    0.0%  t std::__1::ostreambuf_iterator&lt;char, std::__1::char_traits&lt;char&gt; &gt; std::__1::__pad_and_output&lt;char, std::__1::char_traits&lt;char&gt; &gt;(std::__1::ostreambuf_iterator&lt;char, std::__1::char_traits&lt;char&gt; &gt;, char const*, char const*, char const*, std::__1::ios_base&amp;, char)
      2    0.0%    0.0%  T _mach_get_times
      1    0.0%    0.0%  T _mig_dealloc_reply_port
      1    0.0%    0.0%  T __simple_putline
      1    0.0%    0.0%  T ___psynch_cvbroad
</code></pre></div></div> <p>Все еще не очень понятно :( на самом деле, иногда все становится понятно и из этой секции — но не в этот раз. Чтобы лучшве понять, что это за <code class="language-plaintext highlighter-rouge">node::contextify::ContextifyScript::~ContextifyScript()</code>, отбирающий 98% процессорного времени, обратимся к секции <code class="language-plaintext highlighter-rouge">Bottom up (heavy) profile</code>, которая предоставляет информацию о том,где чаще всего вызывается каждая функция. Там мы видим это:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Bottom up (heavy) profile]:
  Note: percentage shows a share of a particular caller in the total
  amount of its parent calls.
  Callers occupying less than 1.0% are not shown.

   ticks parent  name
   5357   97.3%  T node::contextify::ContextifyScript::~ContextifyScript()
   5036   94.0%    Function: ^pbkdf2Sync node:internal/crypto/pbkdf2:68:20
   4993   99.1%      Function: ^&lt;anonymous&gt; file:///Users/sptm/Documents/Development/test/fastify/express-app.js:28:18
   4993  100.0%        Function: ^handle /Users/sptm/Documents/Development/test/fastify/node_modules/express/lib/router/layer.js:86:49
   4888   97.9%          Function: ^next /Users/sptm/Documents/Development/test/fastify/node_modules/express/lib/router/route.js:116:16
   4888  100.0%            Function: ^dispatch /Users/sptm/Documents/Development/test/fastify/node_modules/express/lib/router/route.js:98:45
    105    2.1%          LazyCompile: ~next /Users/sptm/Documents/Development/test/fastify/node_modules/express/lib/router/route.js:116:16
    105  100.0%            Function: ^dispatch /Users/sptm/Documents/Development/test/fastify/node_modules/express/lib/router/route.js:98:45
    194    3.6%    LazyCompile: ~pbkdf2Sync node:internal/crypto/pbkdf2:68:20
    173   89.2%      LazyCompile: ~&lt;anonymous&gt; file:///Users/sptm/Documents/Development/test/fastify/express-app.js:28:18
    107   61.8%        Function: ^handle /Users/sptm/Documents/Development/test/fastify/node_modules/express/lib/router/layer.js:86:49
    107  100.0%          LazyCompile: ~next /Users/sptm/Documents/Development/test/fastify/node_modules/express/lib/router/route.js:116:16
    107  100.0%            LazyCompile: ~dispatch /Users/sptm/Documents/Development/test/fastify/node_modules/express/lib/router/route.js:98:45
     66   38.2%        LazyCompile: ~handle /Users/sptm/Documents/Development/test/fastify/node_modules/express/lib/router/layer.js:86:49
     66  100.0%          LazyCompile: ~next /Users/sptm/Documents/Development/test/fastify/node_modules/express/lib/router/route.js:116:16
     66  100.0%            LazyCompile: ~dispatch /Users/sptm/Documents/Development/test/fastify/node_modules/express/lib/router/route.js:98:45
     21   10.8%      LazyCompile: ~&lt;anonymous&gt; file:///Users/sptm/Documents/Development/test/fastify/express-app.js:9:21
     21  100.0%        LazyCompile: ~handle /Users/sptm/Documents/Development/test/fastify/node_modules/express/lib/router/layer.js:86:49
     21  100.0%          LazyCompile: ~next /Users/sptm/Documents/Development/test/fastify/node_modules/express/lib/router/route.js:116:16
     21  100.0%            LazyCompile: ~dispatch /Users/sptm/Documents/Development/test/fastify/node_modules/express/lib/router/route.js:98:45
</code></pre></div></div> <h2 id="оптимизация">Оптимизация</h2> <p>А вот отсюда очевидно, что практически все процессорное время отнимает функция <code class="language-plaintext highlighter-rouge">pbkdf2Sync()</code>, которой мы генерируем хэш на основе пароля. К счастью, мы понимаем, что эта функция работает синхронно и блокирует event loop (если не понимаем, о чем речь, читаем вот эту <a href="https://sptm.dev/ru/2023/asynchrony-in-js/">статью об асинхронности</a>). Попробуем использовать асинхронную версию функции <code class="language-plaintext highlighter-rouge">pbkdf2Sync()</code> (<code class="language-plaintext highlighter-rouge">pbkdf2()</code>):</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">app</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">/auth</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">,</span> <span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">username</span> <span class="o">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">query</span><span class="p">.</span><span class="nx">username</span> <span class="o">||</span> <span class="dl">''</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">password</span> <span class="o">=</span> <span class="nx">req</span><span class="p">.</span><span class="nx">query</span><span class="p">.</span><span class="nx">password</span> <span class="o">||</span> <span class="dl">''</span><span class="p">;</span>

  <span class="nx">username</span> <span class="o">=</span> <span class="nx">username</span><span class="p">.</span><span class="nf">replace</span><span class="p">(</span><span class="sr">/</span><span class="se">[</span><span class="sr">!@#$%^&amp;*</span><span class="se">]</span><span class="sr">/g</span><span class="p">,</span> <span class="dl">''</span><span class="p">);</span>

  <span class="k">if </span><span class="p">(</span><span class="o">!</span><span class="nx">username</span> <span class="o">||</span> <span class="o">!</span><span class="nx">password</span> <span class="o">||</span> <span class="nx">users</span><span class="p">[</span><span class="nx">username</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">.</span><span class="nf">sendStatus</span><span class="p">(</span><span class="mi">400</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nx">crypto</span><span class="p">.</span><span class="nf">pbkdf2</span><span class="p">(</span><span class="nx">password</span><span class="p">,</span> <span class="nx">users</span><span class="p">[</span><span class="nx">username</span><span class="p">].</span><span class="nx">salt</span><span class="p">,</span> <span class="mi">10000</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="dl">'</span><span class="s1">sha512</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">hash</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if </span><span class="p">(</span><span class="nx">users</span><span class="p">[</span><span class="nx">username</span><span class="p">].</span><span class="nx">hash</span><span class="p">.</span><span class="nf">toString</span><span class="p">()</span> <span class="o">===</span> <span class="nx">hash</span><span class="p">.</span><span class="nf">toString</span><span class="p">())</span> <span class="p">{</span>
      <span class="nx">res</span><span class="p">.</span><span class="nf">sendStatus</span><span class="p">(</span><span class="mi">200</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">res</span><span class="p">.</span><span class="nf">sendStatus</span><span class="p">(</span><span class="mi">401</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">});</span>
<span class="p">});</span>
</code></pre></div></div> <p>И снова сымитируем нагрузку. Получим такие результаты:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Concurrency Level:      20
Time taken for tests:   0.073 seconds
Complete requests:      250
Failed requests:        0
Non-2xx responses:      250
Keep-Alive requests:    250
Total transferred:      62000 bytes
HTML transferred:       2750 bytes
Requests per second:    3444.38 [#/sec] (mean)
Time per request:       5.807 [ms] (mean)
Time per request:       0.290 [ms] (mean, across all concurrent requests)
Transfer rate:          834.19 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:        0    1   3.2      0      14
Processing:     1    4   2.7      3      18
Waiting:        1    3   2.6      3      16
Total:          1    4   5.4      3      24

Percentage of the requests served within a certain time (ms)
  50%      3
  66%      3
  75%      3
  80%      4
  90%      7
  95%     22
  98%     23
  99%     23
 100%     24 (longest request)
</code></pre></div></div> <p>Сильно лучше, правда? От 38 запросов в секунду мы выросли практически на два порядка, до 3444 запросов. А один запрос теперь занимает около 5 миллисекунд вместо 529.</p> <h2 id="итоги">Итоги</h2> <p>Надеюсь, на этом полностью синтетическом и выдуманном примере мы научились профилировать наши приложения. Ну, и поняли, насколько вредны синхронные блокирующие операции :)</p>]]></content><author><name></name></author><category term="javascript"/><category term="js"/><summary type="html"><![CDATA[Статья о профилировании и оптимизации Node.js-приложений.]]></summary></entry><entry><title type="html">Docker: что, зачем и почему</title><link href="https://sptm.dev/ru/2023/docker/" rel="alternate" type="text/html" title="Docker: что, зачем и почему"/><published>2023-03-05T18:33:43+00:00</published><updated>2023-03-05T18:33:43+00:00</updated><id>https://sptm.dev/ru/2023/docker</id><content type="html" xml:base="https://sptm.dev/ru/2023/docker/"><![CDATA[<h2 id="введение">Введение</h2> <p>Наверное, не осталось компаний, которые игнорируют Docker. Docker — очевидный стандарт в индустрии уже несколько лет, очень удобен и в разработке, и для деплоя (а инструменты оркестрации контейнеров очень помогают в деплое контейнеров в больших приложениях). Здесь я расскажу, как он работает, почему его минусы выдуманы и как с ним вообще работать.</p> <h2 id="начнем-сначала-виртуализация">Начнем сначала: виртуализация</h2> <p>Когда-то, чтобы на одном сервере изолированно запускать несколько окружений (в данном случае — операционных систем в хостовой операционной системе), мы использовали виртуализацию. Виды виртуализации (аппаратная, программная) мы с вами здесь разбирать не будем — статья совсем не о том. Вкратце — есть программа-гипервизор, которая умеет запускать виртуальные компьютеры внутри операционной системы — хоста.</p> <p>Звучит круто, правда? Но затраты ресурсов на сам гипервизор не радуют совсем. Поэтому в 2005 году разработчики Linux добавили в ядро такую штуку, как OpenVZ.</p> <h3 id="openvz">OpenVZ</h3> <p>OpenVZ — это первая попытка уйти от виртуализации в привычном смысле и сократить использование ресурсов. Это технология виртуализации на уровне операционной системы (если точнее, то на уровне ядра Linux). Как говорят разработчики Linux, затраты на виртуализацию составляют всего 1-3%, что несравнимо меньше стандартных на тот момент решений.</p> <p>Но появилось ограничение: с помощью OpenVZ можно запускать только дистрибутивы Linux.</p> <h2 id="плавно-перейдем-к-контейнерам">Плавно перейдем к контейнерам</h2> <p>Вернемся в 2002 год, когда в ядро Linux добавили первое пространство имен для изоляции файловой системы — <code class="language-plaintext highlighter-rouge">mount</code>. А в 2007 году Google разработал Process Containers, который умел ограничивать использование аппаратных ресурсов для процессов. Позднее этот механизм, к тому времени переименованный в <code class="language-plaintext highlighter-rouge">cgroups</code>, был добавлен в ядро Linux. В 2013 году это расширили и добавили в ядро пространства имен пользователей (<code class="language-plaintext highlighter-rouge">user</code>).</p> <p>А еще в 2008 году (простите, что так перемещаюсь во времени, но так нужно) в Linux добавили такую штуку, как Linux Containers (LXC).</p> <h3 id="lxc">LXC</h3> <p>Эта штука умела запускать несколько контейнеров Linux на одном сервере. Она использовала уже существующий <code class="language-plaintext highlighter-rouge">cgroups</code> и неймспейсы. И это рано или поздно должно было превратиться во что-то очень важное и удобное. Так и случилось.</p> <h3 id="docker">Docker</h3> <p>Наконец-то мы доехали до основной темы статьи :) в 2013 году никому не известная компания Docker, Inc выпустила свой продукт — Docker. На тот момент Docker был просто удобной оберткой над LXC, но именно из-за удобства он очень быстро набрал популярность.</p> <p>Позднее он перешел на собственную библиотеку <code class="language-plaintext highlighter-rouge">libcontainer</code> (не менее связанную с ядром Linux). А когда стало понятно, что контейнеры — это надолго, компании Linux Foundation и Docker в 2015 году создали Open Container Initiative, которая до сих пор занимается разработкой стандартов для Linux-контейнеров.</p> <h4 id="в-чем-вообще-прикол-контейнеров">В чем вообще прикол контейнеров?</h4> <p>Контейнеры — это такая прекрасная штука, которая может запустить операционную систему (Linux, да) в отдельном процессе, изолированном от остальной системы. Сам он будет уверен, что в системе только он и запущен. А изоляция эта обеспечивается все теми же <code class="language-plaintext highlighter-rouge">containers</code> и <code class="language-plaintext highlighter-rouge">cgroups</code>. Собственно, Docker так и работает.</p> <h4 id="давайте-определимся-с-понятиями-не-теми-что-на-зоне">Давайте определимся с понятиями (не теми, что на зоне)</h4> <ul> <li>Image. Образ. Файл, в который упакована среда исполнения приложения и самое это приложение. То, из чего вы запускаете контейнеры.</li> <li>Registry Server. То место, где хранятся образы — туда мы можем запушить наш образ или стянуть оттуда существующий. Самый популярный и дефолтный — <a href="https://hub.docker.com">Docker Hub</a>, но можно создавать и свои.</li> <li>Container. То, что запускается из образа, тот самый изолированный процесс.</li> <li>Container Engine. Движок контейнеризации. То, что скачивает образы и запускает контейнеры (ну, не совсем, это нам так кажется). Ну, собственно, главный пример — Docker.</li> <li>Container Runtime. А вот эта штука действительно запускает контейнеры. <code class="language-plaintext highlighter-rouge">runc</code>, <code class="language-plaintext highlighter-rouge">crun</code>, вот это все.</li> <li>Host. Система, где все это происходит.</li> </ul> <h3 id="а-теперь-можно-и-к-практике">А теперь можно и к практике</h3> <p>Что мы с этим докером делаем? Скачиваем образы (по дефолту с Docker Hub, но можно указать и другой registry server). Это делается командой <code class="language-plaintext highlighter-rouge">docker pull</code>. К примеру: <code class="language-plaintext highlighter-rouge">docker pull mongo:6.2</code> скачает вам образ MongoDB версии 6.2. Если не указывать версию явно, скачается последняя версия (<code class="language-plaintext highlighter-rouge">latest</code>). Команда эта необязательна: мы можем сделать <code class="language-plaintext highlighter-rouge">docker create mongo:6.2</code> (создать на основе скачанного образа контейнер) или <code class="language-plaintext highlighter-rouge">docker run mongo:6.2</code> (создать из образа контейнер и запустить его). Тогда образ скачается автоматически, если он еще не скачан.</p> <p>Вот самые популярные команды, которые мы запускаем:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># справочная информация</span>
docker <span class="nt">--help</span> <span class="c"># список доступных команд</span>
docker &lt;<span class="nb">command</span><span class="o">&gt;</span> <span class="nt">--help</span> <span class="c"># информация по команде</span>

docker <span class="nt">--version</span> <span class="c"># версия Docker</span>
docker info <span class="c"># общая информация о системе</span>

<span class="c"># работа с образами</span>
docker search debian <span class="c"># поиск образов по ключевому слову debian</span>

docker pull ubuntu <span class="c"># скачивание последней версии (тег по умолчанию latest) официального образа ubuntu (издатель не указывается) из репозитория по умолчанию docker.io/library</span>
docker pull prom/prometheus <span class="c"># скачивание последней версии (latest) образа prometheus от издателя prom из репозитория docker.io/prom</span>
docker pull docker.io/library/ubuntu:18.04 <span class="c"># скачивание из репозитория docker.io официального образа ubuntu с тегом 18.04</span>

docker images <span class="c"># просмотр локальных образов</span>

docker rmi &lt;image_name&gt;:&lt;tag&gt; <span class="c"># удаление образа. Вместо &lt;image_name&gt;:&lt;tag&gt; можно указать &lt;image_id&gt;. Для удаления образа все контейнеры на его основе должны быть как минимум остановлены</span>
docker rmi <span class="si">$(</span>docker images <span class="nt">-aq</span><span class="si">)</span> <span class="c"># удаление всех образов</span>

<span class="c"># работа с контейнерами</span>
docker run hello-world <span class="c"># Hello, world! в мире контейнеров</span>
docker run <span class="nt">-it</span> ubuntu bash <span class="c"># запуск контейнера ubuntu и выполнение команды bash в интерактивном режиме</span>
docker run <span class="nt">--name</span> docker-getting-started <span class="nt">--publish</span> 8080:80 docker/getting-started <span class="c"># запуск контейнера gettind-started с отображением (маппингом) порта 8080 хоста на порт 80 внутрь контейнера</span>
docker run <span class="nt">--detach</span> <span class="nt">--name</span> mongodb docker.io/library/mongo:4.4.10 <span class="c"># запуск контейнера mongodb с именем mongodb в фоновом режиме. Данные будут удалены при удалении контейнера!</span>

docker ps <span class="c"># просмотр запущенных контейнеров</span>
docker ps <span class="nt">-a</span> <span class="c"># просмотр всех контейнеров (в том числе остановленных)</span>
docker stats <span class="nt">--no-stream</span> <span class="c"># просмотр статистики</span>

docker start alpine <span class="c"># создание контейнера из образа alpine</span>

docker start &lt;container_name&gt; <span class="c"># запуск созданного контейнера. Вместо &lt;container_name&gt; можно указать &lt;container_id&gt;</span>
docker start <span class="si">$(</span>docker ps <span class="nt">-a</span> <span class="nt">-q</span><span class="si">)</span> <span class="c"># запуск всех созданных контейнеров</span>

docker stop &lt;container_name&gt; <span class="c"># остановка контейнера. Вместо &lt;container_name&gt; можно указать &lt;container_id&gt;</span>
docker stop <span class="si">$(</span>docker ps <span class="nt">-a</span> <span class="nt">-q</span><span class="si">)</span> <span class="c"># остановка всех контейнеров</span>

docker <span class="nb">rm</span> &lt;container_name&gt; <span class="c"># удаление контейнера. Вместо &lt;container_name&gt; можно указать &lt;container_id&gt;</span>
docker <span class="nb">rm</span> <span class="si">$(</span>docker ps <span class="nt">-a</span> <span class="nt">-q</span><span class="si">)</span> <span class="c"># удаление всех контейнеров</span>

<span class="c"># система</span>
docker system info <span class="c"># общая информация о системе (соответствует docker info)</span>
docker system <span class="nb">df</span> <span class="c"># занятое место на диске</span>
docker system prune <span class="nt">-af</span> <span class="c"># удаление неиспользуемых данных и очистка диска</span>
</code></pre></div></div> <p>Есть прикол: внутри контейнера есть собственная файловая система, которая снаружи не видна и удаляется при удалении контейнера. Иногда мы хотим пробросить какие-то файлы внутрь контейнера, чтобы сохранить их на хосте (ну, к примеру, с той же монгой мы наверняка хотим иметь все данные в базе локально). Так как мы можем пошарить данные контейнера с хостом?</p> <p>Есть два метода:</p> <ul> <li>named volumes — именованные тома хранения данных. Cохраняются в <code class="language-plaintext highlighter-rouge">./docker/volumes</code>, не удаляются при удалении контейнера, могут шариться между несколькими контейнерами.</li> <li>bind mount — монтирование каталога с хоста в контейнер. Простой проброс каталога с хоста в контейнер. Таким образом, данные в проброшенных файлах доступны и хранятся локально.</li> </ul> <p>Вот как это все использовать:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># справочная информация</span>
docker &lt;<span class="nb">command</span><span class="o">&gt;</span> <span class="nt">--help</span>

<span class="c"># named volume</span>
docker run <span class="nt">--detach</span> <span class="nt">--name</span> jenkins <span class="nt">--publish</span> 80:8080 <span class="nt">--volume</span><span class="o">=</span>jenkins_home:/var/jenkins_home/ jenkins/jenkins:lts-jdk11 <span class="c"># запуск контейнера jenkins с подключением каталога /var/jenkins_home как тома jenkins_home</span>
docker volume <span class="nb">ls</span> <span class="c"># просмотр томов</span>
docker volume prune <span class="c"># удаление неиспользуемых томов и очистка диска. Для удаления тома все контейнеры, в которых он подключен, должны быть остановлены и удалены</span>

<span class="c"># bind mount</span>
<span class="c"># запуск контейнера node-exporter с монтированием каталогов внутрь контейнера в режиме read only: /proc хоста прокидывается в /host/proc:ro внутрь контейнера, /sys - в /host/sys:ro, а / - в /rootfs:ro</span>
docker run <span class="se">\</span>
<span class="nt">-p</span> 9100:9100 <span class="se">\</span>
<span class="nt">-v</span> <span class="s2">"/proc:/host/proc:ro"</span> <span class="se">\</span>
<span class="nt">-v</span> <span class="s2">"/sys:/host/sys:ro"</span> <span class="se">\</span>
<span class="nt">-v</span> <span class="s2">"/:/rootfs:ro"</span> <span class="se">\</span>
<span class="nt">--name</span> node-exporter prom/node-exporter:v1.1.2
</code></pre></div></div> <h4 id="создание-образов">Создание образов</h4> <p>Да, можно не просто качать уже существующие образы, но и создавать свои. Есть такая штука — <code class="language-plaintext highlighter-rouge">Dockerfile</code>.</p> <p>Вот супер-базовый пример создания образов (на самом деле, этот самый докерфайл — просто набор команд, которые нужно выполнить, чтобы создать образ):</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Dockerfile</span>
<span class="c"># создание файла Dockerfile декларативного описания</span>
FROM ubuntu:20.04
RUN apt-get update <span class="o">&amp;&amp;</span> apt-get <span class="nb">install</span> <span class="nt">-y</span> iputils-ping

<span class="c"># запуск команды build из каталога с Dockerfile для создания образа simust/ubuntu-ping:20.04</span>
docker build <span class="nt">-t</span> ubuntu-ping:20.04 <span class="nb">.</span>
docker images

<span class="c"># tag, login, push</span>
docker tag ubuntu-ping:20.04 our-registry/ubuntu-ping:20.04 <span class="c"># создание из локального образа ubuntu-ping:20.04 тега с репозиторием для издателя simust</span>
docker images
<span class="c"># вход в репозиторий docker.io под пользователем simust и отправка образа</span>
docker login <span class="nt">-u</span> simust docker.io
docker push our-registry/ubuntu-ping:20.04
</code></pre></div></div> <p>Понятно, что registry можно не указывать, если нам достаточно иметь образ локально или мы хотим использовать Docker Hub как дефолтный registry.</p> <h4 id="docker-compose">Docker Compose</h4> <p>Docker Compose — это такая удобная простая штука для развертывания проектов. Она объединяет в себе сборку, загрузку и запуск нескольких контейнеров. По умолчанию для такого используется файл <code class="language-plaintext highlighter-rouge">docker-compose.yml</code>.</p> <p>Выглядеть он может примерно так:</p> <div class="language-docker highlighter-rouge"><div class="highlight"><pre class="highlight"><code>version: '3.5'
services:
  postgres:
    image: postgres:latest
    restart: unless-stopped
    volumes:
      - ./private/var/lib/postgresql:/var/lib/postgresql
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
      - POSTGRES_DB=test_app_db
    healthcheck:
      test: ['CMD-SHELL', 'pg_isready -U postgres']
      interval: 5s
      timeout: 5s
      retries: 5
    ports:
      - '5432:5432'

  mongo:
    image: mongo:latest
    restart: unless-stopped
    volumes:
      - ./private/mongodb_data_container:/var/lib/postgresql
    healthcheck:
      test: echo 'db.runCommand({serverStatus:1}).ok' | mongosh admin -u root -p rootpassword --quiet | grep 1
      interval: 5s
      timeout: 5s
      retries: 5
    environment:
      MONGO_INITDB_ROOT_USERNAME: root
      MONGO_INITDB_ROOT_PASSWORD: rootpassword
    ports:
      - "27017:27017"
  api:
    build:
      context: ./
      dockerfile: ./deploy/Dockerfile
    environment:
      - POSTGRES_DB_HOST=postgres
      - POSTGRES_DB_USERNAME=postgres
      - POSTGRES_DB_PASSWORD=postgres
      - POSTGRES_DB_NAME=test_app_db
      - POSTGRES_DB_PORT=5432
      - MONGO_HOST=mongo
      - MONGO_USERNAME=root
      - MONGO_PASSWORD=rootpassword
      - MONGO_PORT:27017
      - APP_PORT:3000
    ports:
      - "3000:3000"
    depends_on:
      mongo:
        condition: service_healthy
      postgres:
        condition: service_healthy
</code></pre></div></div> <p>Выглядит понятно, правда? Мы хотим скачать последние версии postgres и mongo и сбилдить наше приложение из докерфайла, после чего запустить все это добро, дождаться готовности postgres и mongo и запустить наше приложение, сделав так, чтобы оно было доступно на 3000 порту.</p> <p>Cобираем мы все это дело так: <code class="language-plaintext highlighter-rouge">docker-compose build</code>, а запускаем так: <code class="language-plaintext highlighter-rouge">docker-compose up</code>. Стопнуть все можно так: <code class="language-plaintext highlighter-rouge">docker-compose down</code>, почитать логи так: <code class="language-plaintext highlighter-rouge">docker-compose logs -f app</code>. <code class="language-plaintext highlighter-rouge">docker-compose ps</code> покажет нам запущенные сервисы, а <code class="language-plaintext highlighter-rouge">docker-compose exec [service name] [command]</code> — выполнить команду внутри запущенного сервера.</p> <h2 id="итоги">Итоги</h2> <p>Я очень постарался просто и коротко все объяснить, но в статье такого формата не распишешь все возможности Docker. Эта статья поможет вам базово научиться работать с докером, но, пожалуйста, привыкайте читать документацию. Вот она, <a href="https://docs.docker.com">документация</a> — там все сильно подробнее.</p> <p>А так — ну, контейнер вы запустить сможете, образ сбилдить — тоже. Уже неплохо.</p>]]></content><author><name></name></author><category term="theory"/><category term="other"/><category term="theory"/><category term="other"/><summary type="html"><![CDATA[Статья о Docker, как он работает, зачем нужен и как им пользоваться.]]></summary></entry><entry><title type="html">Микросервисы или монолит?</title><link href="https://sptm.dev/ru/2023/microservices-vs-monolith/" rel="alternate" type="text/html" title="Микросервисы или монолит?"/><published>2023-03-05T06:28:43+00:00</published><updated>2023-03-05T06:28:43+00:00</updated><id>https://sptm.dev/ru/2023/microservices-vs-monolith</id><content type="html" xml:base="https://sptm.dev/ru/2023/microservices-vs-monolith/"><![CDATA[<h2 id="введение">Введение</h2> <p>Где-то года с 2014 слово “микросервисы” плотно вошло в айтишечку, да так, что создавалось мнение, что микросервисная архитектура — панацея. Так вот — нет :) об этом и статья. Мы разберемся, когда микросервисы нужны, когда они мешают, да и вообще коснемся сервис-ориентированной архитектуры.</p> <h3 id="монолиты">Монолиты</h3> <p>Что такое монолит? Мы пишем приложение, не деля его на части, запуская его целиком. Почему это удобно? Сразу видна вся логика приложения, не нужно заботиться о взаимосвязях, легче писать — вся бизнес-логика, работа со всеми данными — все это в одном месте. Монолит легче тестировать (особенно это касается end-to-end тестов) и проще запускать.</p> <p>Сложности начинаются с ростом техдолга: становится все сложнее и сложнее добавлять новые фичи и фиксить баги из-за высокой связности (как писать код правильно, читайте <a href="https://sptm.dev/ru/2023/solid-grasp-and-stuff/">здесь</a>). Когда монолит растет, неизбежно возникают проблемы, когда некоторые части приложения требуют больше ресурсов. Тогда мы вынуждены либо масштабировать приложение вертикально (просто увеличивать количество выделенных ресурсов), либо горизонтально масштабировать (запускать несколько инстансов приложения) монолит целиком, что достаточно ресурсоемко. Отсюда перейдем к тому, что называется сервис-ориентированной архитектурой (и как это обычно выглядит в реальности).</p> <h3 id="сервис-ориентированная-архитектура">Сервис-ориентированная архитектура</h3> <p>В идеале сервис-ориентированная архитектура — это куча слабо связанных между собой сервисов, взаимодействующих по какому-то заранее определенному контракту: Взаимодействие может быть выстроено по <a href="https://sptm.dev/ru/2023/http-in-details/">HTTP</a>, gRPC, очередям сообщений и как только не. Самый важный аспект — это та самая слабая связность сервисов — это позволяет выделять доменные области в отдельные сервисы.</p> <p>Как это обычно происходит в реальности — другой вопрос. Часто из изначально монолитного приложения по каким-то причинам (разделение разработки по группам, удобство масштабирования) выделяют отдельные сервисы. Другое дело, что связность сложно разорвать — и сервисы начинают использовать одну и ту же базу данных и вообще цепляться друг за друга как только могут. Этого, конечно, можно избежать, если изначально придерживаться такой архитектуры — но это бывает редко. В отличие от микросервисов.</p> <h4 id="микросерверная-архитектура">Микросерверная архитектура</h4> <p>Микросервис — это такой подвид сервисов, который обязательно исполняет какую-то одну небольшую функциональность. Он обязательно полностью изолирован от других микросервисов и на уровне данных (используя отдельную базу), и на уровне доменной области, и на уровне бизнес-логики. Проще говоря, это абсолютно отдельное очень маленькое приложение.</p> <p>Так же, как и сервисы, они взаимодействуют друг с другом как отдельные сторонние приложения. В них из-за отсутствия связности легко вносить изменения (соблюдая контракт взаимодействия, конечно). Еще прикольно то, что в больших компаниях разные команды могут независимо друг от друга работать над разными микросервисами.</p> <p>Проблема в том, что часто выстроить взаимодействие между микросервисами гораздо сложнее, чем объединить их в монолит. То есть, взаимодействие между микросервисами попросту становится самой сложной частью приложения. Если команда небольшая, а контракт взаимодействия не выстроен идеально, мы получаем те же проблемы, что и с обычными сервисами,</p> <p>А деплой? Деплоить микросервисы гораздо сложнее, чем монолит. Спасибо контейнеризации и штукам для оркестрации типа Kubernetes, это чуть все упрощает, но не отменяет того, что деплоить микросервисы сложнее. А если нужно внести изменения сразу в несколько микросервисов? Взаимодействие разработчиков становится в этом случае очень и очень сложным.</p> <h2 id="выводы">Выводы</h2> <p>А выводы просты. У вас много команд? Микросервисы могут облегчить разработку (хоть и не всегда). Если у вас небольшая команда, пожалуйста, не ведитесь на хайп микросервисов и пилите монолит, стараясь сохранять низкую связность, закладывая в приложение модульность, В этом случае вы при необходимости сможете сравнительно легко выделить что-то в отдельный сервис.</p> <p>А микросервисы оставьте большим компаниям: они справятся с их минусами и выстроят процессы так, чтобы сократить усилия на их взаимодействие. Заодно они из коробки получат легкую балансировку отдельных частей приложения, а тонна девопсов вывезет деплой. Останутся проблемы с E2E-тестированием, но интеграционные и юнит-тесты писать будет проще.</p> <p>В общем, короткий ответ: маленькая команда? Начните с монолита. Много команд? Проработайте взаимодействие между ними, строго обговорите контракт и пилите микросервисы.</p>]]></content><author><name></name></author><category term="theory"/><category term="other"/><category term="theory"/><category term="other"/><summary type="html"><![CDATA[Статья о микросервисах и монолитах, преимуществах и недостатках.]]></summary></entry><entry><title type="html">Аутентификация, авторизация, идентификация и прочие сложные слова</title><link href="https://sptm.dev/ru/2023/authentication/" rel="alternate" type="text/html" title="Аутентификация, авторизация, идентификация и прочие сложные слова"/><published>2023-03-03T16:10:43+00:00</published><updated>2023-03-03T16:10:43+00:00</updated><id>https://sptm.dev/ru/2023/authentication</id><content type="html" xml:base="https://sptm.dev/ru/2023/authentication/"><![CDATA[<h2 id="введение">Введение</h2> <p>Мы далеко не всегда хотим, чтобы наш бэкенд был доступен всем просто так. На самом деле, чаще всего мы хотим обратного. Сегодня я расскажу вам, что такое аутентификация и авторизация, какие виды аутентификации существуют и как они работают. Судя по количеству вопросов на эту тему, будет интересно :)</p> <h3 id="терминология">Терминология</h3> <p>Есть три штуки, которые очень часто путают:</p> <ul> <li>идентификация: попросту говоря, ваш логин или что-то такое. То есть, таким способом вы заявляете, кто вы такой.</li> <li>аутентификация: доказательство, что вы и вправду тот, кем себя идентифицировали: пароль, ключ, такие штуки</li> <li>авторизация: проверка, что вы имеете доступ к тому ресурсу, что запрашиваете</li> </ul> <p>Если проще, идентификация: получение вашего логина, аутентификация: подтверждение его паролем, авторизация: проверка, что вы можете в приложении делать то, что пытаетесь.</p> <p>Но все чуточку сложнее, чем кажется.</p> <h3 id="аутентификация">Аутентификация</h3> <p>Видов аутентификации на самом деле дофига. Давайте разбираться.</p> <h4 id="аутентификация-по-паролю">Аутентификация по паролю</h4> <h5 id="http-authentication">HTTP Authentication</h5> <h6 id="basic">Basic</h6> <p>Максимально простая штука. В HTTP-заголовке Authorization (о протоколе HTTP подробнее <a href="https://sptm.dev/ru/2023/http-in-details/">здесь</a>) в незашифрованном виде (base64) передаются логин и пароль. Понятно, что штука эта небезопасная, но по HTTPS становится вполне сносной.</p> <h6 id="digest">Digest</h6> <p>Чуть сложнее. Сервер отдает клиенту некое уникальное значение <code class="language-plaintext highlighter-rouge">nonce</code>, а клиент им хэширует пароль MD5</p> <h6 id="windows-authentication">Windows authentication</h6> <p>Даже не буду подробно рассматривать этот вариант. Там тоже пароль в чистом виде не передается, и в этом смысле оно похоже на Digest, но работает только в Active Directory</p> <h6 id="прочие-варианты-аутентификации-по-паролю">Прочие варианты аутентификации по паролю</h6> <p>Это не то чтобы стандарт, но используется довольно часто. Логин с паролем передаются на сервер POST-запросом, он их проверяет и отдает токен, который браузер кладет в cookies и использует впоследствии в каждом запросе.</p> <p>Еще есть вариант, что логин и пароль передаются в заголовке Authorization, а дальше происходит то же самое.</p> <h5 id="аутентификация-по-сертификату">Аутентификация по сертификату</h5> <p>Тоже достаточно простая штука. На стороне клиента хранится сертификат, подписанный каким-то центром сертификации, гарантирующим его подлинность (CA, Certificate Authority).</p> <p>Клиент передает сертификат серверу, а тот проверяет, подписан ли он доверенным CA, действителен ли он (не просрочен ли) и не отозван CA.</p> <h5 id="аутентификация-по-ключу">Аутентификация по ключу</h5> <p>Тут никаких логинов / паролей нет, а есть некий ключ (API key), который генерится на сервере заранее. Чаще всего клиент при каждом запросе в заголовке Authentication передает что-то типа <code class="language-plaintext highlighter-rouge">Authentication: Bearer &lt;token&gt;</code> . Понятно, что такое должно работать только по HTTPS, иначе заголовки можно будет перехватить.</p> <h5 id="авторизация-по-токенам">Авторизация по токенам</h5> <p>Такое часто используется при построении распределенных систем, где одно приложение (service provider) делегирует аутентификацию другому приложению (identity provider). К примеру, многие сервисы делегируют аутентификацию социальным сетям (это когда мы гугл-учеткой аутентифицируемся, к примеру). Называется это все SSO (Single Sign-On).</p> <p>Реализация такова — клиент аутентифицируется каким-то способом в identity provider (например, логином и паролем в Google), identity provider отдает сервис-провайдеру токен, который он использует для идентификации, аутентификации и авторизации пользователя.</p> <h5 id="форматы-токенов">Форматы токенов</h5> <p>Понятно, что суть одна, отличаются только форматы.</p> <h6 id="simple-web-token-swt">Simple Web Token (SWT)</h6> <p>Это токен формата закодированной HTML-формы.</p> <h6 id="json-web-token-jwt">JSON Web Token (JWT)</h6> <p>Этот токен состоит из трех блоков, разделенных точками: первые два (заголовок и набор полей) закодированы base64 и передаются как JSON (как неожиданно). Третий блок — это подпись, их подтверждающая.</p> <h5 id="security-assertion-markup-language-saml">Security Assertion Markup Language (SAML)</h5> <p>Это такие токены в формате XML. Используются редко, их прикол в том, что они содержат механизм для подтверждения владения токеном, что позволяет предотвратить их перехват.</p> <h4 id="oauth--openid-connect">OAuth / OpenID Connect</h4> <p>Вообще, это не метод аутентификации, а способ получения доступа одного приложения к другому от имени пользователя. Но с помощью этого стандарта аутентификацию реализовать все же можно.</p> <p>Работает это примерно так:</p> <ul> <li>пользователь дает разрешение приложению на доступ к определенному ресурсу и получает грант (обычно пара username/password)</li> <li>приложение обращается к серверу авторизации и получает токен доступа к ресурсу в обмен на свой грант</li> <li>приложение использует этот токен для получения требуемых данных от сервера ресурсов</li> </ul> <h2 id="вывод">Вывод</h2> <p>А вывода нет :) мы просто узнали, чем отличаются идентификация, авторизация и аутентификация и рассмотрели самые популярные варианты аутентификации.</p> <p>Я специально не вдавался в подробности, потому что пишу в основном для начинающих разработчиков. А господа сеньоры и так все это знают (а не знают — прочитают, к примеру, <a href="https://habr.com/ru/company/dataart/blog/262817/">здесь</a>) — хорошая статья об этом всем с подробностями.</p> <p>Stay tuned! Новые статьи не за горами.</p>]]></content><author><name></name></author><category term="theory"/><category term="other"/><category term="theory"/><category term="other"/><summary type="html"><![CDATA[Статья об аутентификации, авторизации и идентификации.]]></summary></entry><entry><title type="html">Управление памятью в JS</title><link href="https://sptm.dev/ru/2023/memory-management-in-js/" rel="alternate" type="text/html" title="Управление памятью в JS"/><published>2023-02-26T16:10:43+00:00</published><updated>2023-02-26T16:10:43+00:00</updated><id>https://sptm.dev/ru/2023/memory-management-in-js</id><content type="html" xml:base="https://sptm.dev/ru/2023/memory-management-in-js/"><![CDATA[<h2 id="введение">Введение</h2> <p>JavaScript (а точнее, V8) управляет памятью незаметно для нас, и писать код можно, вообще об этом не заморачиваясь. Но чем серьезнее проект, тем больше приходится беспокоиться об этом, не допускать утечек памяти и в принципе понимать, как оно работает под капотом. Об этом я сегодня и постараюсь рассказать. Статья, наверное, получится не совсем для новичков — но и им это может быть интересно.</p> <h2 id="garbage-collector-сборщик-мусора">Garbage Collector (сборщик мусора)</h2> <p>Вот мы пишем код, создаем функции, объекты, генераторы, <a href="https://sptm.dev/ru/2023/proxy-and-reflect/">Proxy и Reflect</a>, вот это все. Очевидно, оно занимает оперативную память (если чуточку подробнее, то примитивы хранятся в стеке, а все остальное — в куче, но сейчас это не так важно для нас). Соответственно, существует некий жизненный цикл памяти. Давайте о нем чуть подробнее.</p> <h3 id="выделение-памяти">Выделение памяти</h3> <p>Каждый раз, когда мы что-то в нашем коде создаем (переменную, функцию, вот это все), JavaScript незаметно для нас выделяет под это кусок памяти. Собственно, пока это все — дальше мы разберем это подробнее в главе о стеке и куче.</p> <h3 id="использование-памяти">Использование памяти</h3> <p>Этот процесс намного ближе к нам: создавая что-то, мы в память это пишем, используя — читаем. Да, вот так все просто.</p> <h3 id="освобождение-памяти">Освобождение памяти</h3> <p>Это за нас тоже делает JS (V8), и делает он это незаметно для нас. Приятно писать на языках высокого уровня, правда? Дальше разберем, как и когда он это делает.</p> <h2 id="стек-и-куча">Стек и куча</h2> <p>Выделение памяти — понятие очень абстрактное. А где именно хранятся примитивы, функции, объекты? Есть две таких структуры данных: стек и куча. Давайте о них подробнее.</p> <h3 id="стек-статическое-выделение-памяти">Стек (статическое выделение памяти)</h3> <p>Стек — это, во-первых, такая структура данных. Список элементов, которые организованы и обрабатываются по принципу <a href="https://ru.wikipedia.org/wiki/LIFO">LIFO</a> — last in, first out (последним пришел, первым ушел). По этому поводу можно глянуть <a href="https://sptm.dev/ru/2023/asynchrony-in-js/">мою статью об асинхронности в JS</a>, но там не совсем об этом.</p> <p>А во-вторых, это место, где JS хранит примитивные значения (<code class="language-plaintext highlighter-rouge">string</code>, <code class="language-plaintext highlighter-rouge">number</code>, <code class="language-plaintext highlighter-rouge">boolean</code>, <code class="language-plaintext highlighter-rouge">null</code>, <code class="language-plaintext highlighter-rouge">undefined</code>) и ссылки на объекты (на все, что не примитивные значения). Размер таких данных не изменится, поэтому движку удобно — он выделяет фиксированный объем памяти для каждого значения. Процесс выделения памяти прямо перед выполнением называется статическим. Кстати, на размер примитивных значений существует нефиксированный лимит данных. Но то такое, не так важно, как лимит памяти для кучи.</p> <h3 id="куча-динамическое-выделение-памяти">Куча (динамическое выделение памяти)</h3> <p>Куча, если сильно углубиться, это такое <a href="https://ru.wikipedia.org/wiki/Дерево_(структура_данных)">дерево</a>, но нам это не так важно. А важно то, что все, что не примитивы, JS хранит в куче. Если для примитивов заранее известен размер, то объекты, функции и все такое фиксированного размера не имеют. Поэтому JS выделяет память по мере необходимости (динамически), что может порождать утечки памяти (об этом позже).</p> <p>Давайте набросаем небольшой пример — без кода скучновато:</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">val1</span><span class="p">:</span> <span class="dl">'</span><span class="s1">1</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">val2</span><span class="p">:</span> <span class="dl">'</span><span class="s1">2</span><span class="dl">'</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// под этот объект JS выделит память в куче — черт его знает, сколько свойств мы добавим / удалим / поменяем позже</span>
<span class="c1">// кстати, свойства этого объекта — вполне себе примитивы</span>

<span class="kd">const</span> <span class="nx">arr1</span> <span class="o">=</span> <span class="p">[</span> <span class="dl">'</span><span class="s1">string1</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">string2</span><span class="dl">'</span> <span class="p">];</span>

<span class="c1">// массив — это объект, и под него память тоже выделится в куче</span>

<span class="kd">const</span> <span class="nx">test1</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">test1</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">test2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="c1">// а вот это — примитивы. Они хранятся в стеке. Кстати, интересный факт: примитивы неизменяемы, пофиг, объявлены они как var, let или const</span>
<span class="c1">// вместо изменения примитивов JS создает новые.</span>
</code></pre></div></div> <h3 id="ссылки-не-те-что-в-http">Ссылки (не те, что в <a href="https://sptm.dev/ru/2023/http-in-details/">HTTP</a>)</h3> <p>Все переменные (пофиг, на что они указывают / что хранят) хранятся в стеке. Примитивы там хранятся в прямом смысле. С остальным чуть сложнее: в стеке хранятся ссылки на них в куче. В куче порядка нет, поэтому JS и хранит ссылки на них в стеке.</p> <h2 id="концепт-достижимости">Концепт достижимости</h2> <p>Достижимость — сверхважное понятие для того, чтобы понять, как работает сборка мусора. Но ничего шибко сложного в этом нет. Давайте просто: достижимые значения — это те, что находятся в стеке (или ссылка на них находится в стеке). Примеры корневых достижимых значений: выполняемая в текущий момент функция, ее переменные и параметры, другие функции во вложенной цепочке вызовов (и их параметры и переменные), глобальные значения. А любое другое значение будет достижимым, если они доступны из корневых достижимых значений.</p> <p>Давайте по примерам:</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// в obj1 находится ссылка на объект в куче, а свойство prop1, как примитив, хранится в стеке. Оба значения достижимы,</span>
<span class="kd">let</span> <span class="nx">obj1</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">prop1</span><span class="p">:</span> <span class="dl">'</span><span class="s1">1</span><span class="dl">'</span><span class="p">,</span>
<span class="p">}</span>
<span class="c1">// обнуляем obj1, и ссылка теряется. Объект obj1 и его свойства становятся недостижимыми</span>
<span class="nx">obj1</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</code></pre></div></div> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// а если так?</span>
<span class="kd">let</span> <span class="nx">obj1</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">prop1</span><span class="p">:</span> <span class="dl">'</span><span class="s1">1</span><span class="dl">'</span><span class="p">,</span>
<span class="p">}</span>
<span class="kd">const</span> <span class="nx">obj2</span> <span class="o">=</span> <span class="nx">obj1</span><span class="p">;</span>
<span class="nx">obj1</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="c1">// хоть мы и обнулили ссылку в obj1, ссылка на этот объекта осталась в obj2, поэтому он все еще достижим</span>
</code></pre></div></div> <h4 id="взаимосвязанные-объекты">Взаимосвязанные объекты</h4> <p>Чуть сложнее:</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nf">combine</span><span class="p">(</span><span class="nx">val1</span><span class="p">,</span> <span class="nx">val2</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">val1</span><span class="p">.</span><span class="nx">prop1</span> <span class="o">=</span> <span class="nx">val2</span><span class="p">;</span>
    <span class="nx">val2</span><span class="p">.</span><span class="nx">prop2</span> <span class="o">=</span> <span class="nx">val1</span><span class="p">;</span>

    <span class="k">return</span> <span class="p">{</span>
        <span class="na">prop1</span><span class="p">:</span> <span class="nx">val1</span><span class="p">,</span>
        <span class="na">prop2</span><span class="p">:</span> <span class="nx">val2</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">combinedValues</span> <span class="o">=</span> <span class="nf">combine</span><span class="p">({</span>
    <span class="na">property1</span><span class="p">:</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span>
<span class="p">},</span> <span class="p">{</span>
    <span class="na">property2</span><span class="p">:</span> <span class="dl">"</span><span class="s2">2</span><span class="dl">"</span>
<span class="p">});</span>
</code></pre></div></div> <p>Что мы тут сделали? Функция <code class="language-plaintext highlighter-rouge">combine()</code> пересекает объекты, давая им ссылки друг на друга, возвращая объект со ссылками на два предыдущих. Сейчас все объекты достижимы. А если так?</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">delete</span> <span class="nx">combinedValues</span><span class="p">.</span><span class="nx">prop1</span><span class="p">;</span>
<span class="k">delete</span> <span class="nx">combinedValues</span><span class="p">.</span><span class="nx">prop2</span><span class="p">.</span><span class="nx">val2</span><span class="p">;</span>
</code></pre></div></div> <p>И все, у <code class="language-plaintext highlighter-rouge">prop2</code> входящих ссылок больше нет. Но если не удалять одну из ссылок, все объекты останутся достижимыми. А что еще прикольного можно сделать?</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">combinedValues</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// обнуляем combinedValues, он недостижим, и вместе с ним недостижимыми становятся его свойства</span>
</code></pre></div></div> <h2 id="сборка-мусора">Сборка мусора</h2> <p>Вообще, сборка мусора — процесс простой: когда объект/переменная недостижима, он очищает занимаемую ими память. Но проблема есть: однозначно решить, нужна ли выделенная память прямо в момент перехода ее в состояние недостижимости, не выйдет.</p> <p>Нужны какие-то алгоритмы, и они есть: они не полностью точны, но близки к тому. Два самых популярных таких алгоритма — это подсчет ссылок и алгоритм пометок (mark and sweep).</p> <h3 id="алгоритм-подсчета-ссылок">Алгоритм подсчета ссылок</h3> <p>Алгоритм супер-простой: он уничтожает объекты, на которые ссылок больше нет. Но есть проблемка: циклические ссылки он обрабатывать не умеет. Смотрите:</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">obj1</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">prop1</span><span class="p">:</span> <span class="dl">'</span><span class="s1">1</span><span class="dl">'</span><span class="p">,</span>
<span class="p">};</span>
<span class="kd">let</span> <span class="nx">obj2</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">prop2</span><span class="p">:</span> <span class="dl">'</span><span class="s1">2</span><span class="dl">'</span><span class="p">,</span>
<span class="p">}</span>

<span class="nx">obj1</span><span class="p">.</span><span class="nx">obj2</span> <span class="o">=</span> <span class="nx">obj2</span><span class="p">;</span>
<span class="nx">obj2</span><span class="p">.</span><span class="nx">obj2</span> <span class="o">=</span> <span class="nx">obj1</span><span class="p">;</span>
<span class="nx">obj1</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="nx">obj1</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</code></pre></div></div> <p>Вроде как мы обнулили <code class="language-plaintext highlighter-rouge">obj1</code> и <code class="language-plaintext highlighter-rouge">obj2</code>, в чем проблема признать их недостижимыми и очистить занимаемую ими память? Доступа к ним уже нет. Да вот только алгоритм, подсчитывающий ссылки, видит циклические ссылки объектов друг на друга и не считает их недостижимыми.</p> <h3 id="mark-and-sweep-алгоритм-пометок">Mark and Sweep (алгоритм пометок)</h3> <p>Проблему циклических ссылок решает алгоритм пометок. Как он работает? Тоже достаточно просто. Он проверяет, можно ли получить доступ к обьекту через корневой объект (в Node.js это <code class="language-plaintext highlighter-rouge">global</code>, в браузере — <code class="language-plaintext highlighter-rouge">window</code>). Он помечает недоступные объекты (mark) как недостижимые, а после выметает (sweep) их из памяти.</p> <h4 id="проблемы-алгоритмов-очистки-памяти">Проблемы алгоритмов очистки памяти</h4> <p>Есть беда: алгоритмы не знают, в какой момент память станет ненужной. И поэтому приложения на JS могут использовать больше памяти, чем им на самом деле нужно. Ко всему прочему, в однопоточном JS сборщик мусора не может работать постоянно, иначе наш код работать не будет вообще. Сборщик мусора запускается с некоторой периодичностью, но этой периодичностью управлять мы не можем.</p> <p>Для этого и существуют языки с ручным управлением памяти типа С или Rust. В Rust этот вопрос решен особенно интересно, почитайте <a href="https://doc.rust-lang.org/book/">документацию</a>, если интересно — полезно для эрудиции.</p> <h4 id="оптимизации-алгоритмов-очистки-памяти">Оптимизации алгоритмов очистки памяти</h4> <p>Движки JS стараются оптимизировать очистку памяти как можно эффективнее. Вот некоторые из интересных оптимизаций.</p> <h5 id="сборка-по-поколениям-generational-collection">Сборка по поколениям (Generational Collection)</h5> <p>Объекты делятся на два набора: старые и новые. Обычно многие объекты живут недолго: создаются, делают свою работу и умирают. Соответственно, имеет смысл новые объекты проверять чаще. Те, что не проверяются долго, считаются старыми и проверяются реже.</p> <h5 id="инкрементальная-сборка-incremental-collection">Инкрементальная сборка (Incremental collection)</h5> <p>Если объектов много, и сборщик мусора будет их все обходить, это будет долго. Поэтому множество всех объектов делится на части. Тогда одна большая сборка мусора превращается в несколько небольших, и это меньше блокирует поток (а он у нас один, читаем <a href="https://sptm.dev/ru/2023/asynchrony-in-js/">это</a>).</p> <h5 id="сборка-в-свободное-время-idle-time-collection">Сборка в свободное время (Idle-time collection)</h5> <p>А тут все просто: сборщик мусора старается работать тогда, когда процессор наименее загружен.</p> <h2 id="утечки-памяти">Утечки памяти</h2> <p>Давайте коротко разберем то, что делать не нужно, чтобы уменьшить вероятность утечек памяти.</p> <h3 id="глобальные-переменные">Глобальные переменные</h3> <p>Не используйте глобальные переменные! Не используйте <code class="language-plaintext highlighter-rouge">var</code> вместо <code class="language-plaintext highlighter-rouge">let</code> и <code class="language-plaintext highlighter-rouge">const</code>! Это присоединит переменную к глобальному объекту (<code class="language-plaintext highlighter-rouge">window</code> или <code class="language-plaintext highlighter-rouge">global</code>) и помешает алгоритму mark-and-sweep очищать занимаемую имм память, и ваше приложение потечет.</p> <h3 id="забытые-таймеры">Забытые таймеры</h3> <p>Забытые таймеры не очистятся никогда. Смотрите:</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">object</span> <span class="o">=</span> <span class="p">{};</span>
<span class="kd">const</span> <span class="nx">interval</span> <span class="o">=</span> <span class="nf">setInterval</span><span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">doSomething</span><span class="p">(</span><span class="nx">object</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">2000</span><span class="p">);</span>
</code></pre></div></div> <p>Пока <code class="language-plaintext highlighter-rouge">interval</code> не будет очищен, каждые две секунды будет выполняться <code class="language-plaintext highlighter-rouge">doSomething(object)</code>. Не забывайте о <code class="language-plaintext highlighter-rouge">clearInterval</code>, очищайте интервалы!</p> <h2 id="итоги">Итоги</h2> <p>Итак, что нужно помнить:</p> <ul> <li>мы никак не можем повлиять на сборку мусора, она выполняется автоматически</li> <li>достижимые объекты занимают драгоценную память</li> <li>как мы видели в примерах выше, если на объект есть ссылка, он недостижим — смотрите примеры с взаимоссылающимися объектами</li> </ul> <p>А если хочется мясца про V8 и кишки, гляньте <a href="https://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection">офигенную статью</a> о деталях работы сборки мусора в V8.</p> <p>Понимать, как работает garbage collection, важно: если нам требуется низкоуровневая оптимизация, поэтому статейку прочитать полезно, Я не перевожу ее здесь, чтобы не усложнять статью. Всем спасибо за внимание, stay tuned!</p>]]></content><author><name></name></author><category term="javascript"/><category term="js"/><summary type="html"><![CDATA[Статья о cборке мусора в JavaScript — то, что часто остается незаметным]]></summary></entry><entry><title type="html">Модуль Cluster: как сделать Node.js многопоточным</title><link href="https://sptm.dev/ru/2023/cluster/" rel="alternate" type="text/html" title="Модуль Cluster: как сделать Node.js многопоточным"/><published>2023-02-21T10:20:43+00:00</published><updated>2023-02-21T10:20:43+00:00</updated><id>https://sptm.dev/ru/2023/cluster</id><content type="html" xml:base="https://sptm.dev/ru/2023/cluster/"><![CDATA[<h2 id="введение">Введение</h2> <p>Все мы помним, что Node.js по своей природе однопоточен (если не помним, то читаем <a href="https://sptm.dev/ru/2023/asynchrony-in-js/">статью об асинхронности</a>). А что, если нам нужно несколько потоков? К примеру, у нас несколько CPU, и мы хотим использовать всю мощь нашего сервера?</p> <p>В использовании модуля <code class="language-plaintext highlighter-rouge">cluster</code> нет ничего сложного. Проще всего показать это, написав два приложения: одно будет работать в одном потоке, второе — использовать преимущества кластеризации.</p> <h3 id="приложение-в-одном-потоке">Приложение в одном потоке</h3> <p>Напишем простенькое API c использованием Express:</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// создадим приложение Express</span>
<span class="kd">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="nf">express</span><span class="p">();</span>
<span class="kd">const</span> <span class="nx">port</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mi">3000</span><span class="p">;</span>

<span class="c1">// создадим эндпойнт /</span>
<span class="nx">app</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">/</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">req</span><span class="p">:</span> <span class="nx">Request</span><span class="p">,</span> <span class="nx">res</span><span class="p">:</span> <span class="nx">Response</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">res</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="dl">'</span><span class="s1">hello world!</span><span class="dl">'</span><span class="p">)</span>
<span class="p">});</span>

<span class="c1">// запустим приложение Express на порту port</span>
<span class="nx">app</span><span class="p">.</span><span class="nf">listen</span><span class="p">(</span><span class="nx">port</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`app listening on </span><span class="p">${</span><span class="nx">port</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div> <p>Оно будет работать, но не будет использовать все наши CPU, если у нас их больше одного. Перепишем это API с использованием модуля <code class="language-plaintext highlighter-rouge">cluster</code>.</p> <h3 id="приложение-в-нескольких-потоках">Приложение в нескольких потоках</h3> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">express</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">express</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">cluster</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">cluster</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">os</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">os</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">Request</span><span class="p">,</span> <span class="nx">Response</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">express</span><span class="dl">'</span><span class="p">;</span>

<span class="c1">// посчитаем количество CPU с помощью модуля os</span>
<span class="kd">const</span> <span class="nx">totalCPUs</span> <span class="o">=</span> <span class="nx">os</span><span class="p">.</span><span class="nf">cpus</span><span class="p">().</span><span class="nx">length</span><span class="p">;</span>

<span class="c1">// если мы запускаем кластер</span>
<span class="k">if </span><span class="p">(</span><span class="nx">cluster</span><span class="p">.</span><span class="nx">isPrimary</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`number of CPUs is </span><span class="p">${</span><span class="nx">totalCPUs</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`Master </span><span class="p">${</span><span class="nx">process</span><span class="p">.</span><span class="nx">pid</span><span class="p">}</span><span class="s2"> is running`</span><span class="p">);</span>

  <span class="k">for </span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">totalCPUs</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">cluster</span><span class="p">.</span><span class="nf">fork</span><span class="p">();</span> <span class="c1">// форкаем API столько раз, сколько у нас CPU</span>
  <span class="p">}</span>

  <span class="c1">// если кластер умрет, запустим еще один</span>
  <span class="nx">cluster</span><span class="p">.</span><span class="nf">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">exit</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">worker</span><span class="p">:</span> <span class="nx">Worker</span><span class="p">,</span> <span class="nx">code</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">signal</span><span class="p">:</span> <span class="kr">string</span> <span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`worker </span><span class="p">${</span><span class="nx">process</span><span class="p">.</span><span class="nx">pid</span><span class="p">}</span><span class="s2"> died`</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Let's fork another worker!</span><span class="dl">"</span><span class="p">);</span>
    <span class="nx">cluster</span><span class="p">.</span><span class="nf">fork</span><span class="p">();</span>
  <span class="p">})</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// если запускается воркер</span>
  <span class="c1">// создадим приложение Express</span>
  <span class="kd">const</span> <span class="nx">app</span> <span class="o">=</span> <span class="nf">express</span><span class="p">();</span>
  <span class="kd">const</span> <span class="na">port</span><span class="p">:</span> <span class="kr">number</span> <span class="o">=</span> <span class="mi">3000</span><span class="p">;</span>

  <span class="c1">// создадим эндпойнт /</span>
  <span class="nx">app</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">/</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="na">req</span><span class="p">:</span> <span class="nx">Request</span><span class="p">,</span> <span class="na">res</span><span class="p">:</span> <span class="nx">Response</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">res</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="dl">'</span><span class="s1">hello world!</span><span class="dl">'</span><span class="p">)</span>
  <span class="p">});</span>

  <span class="c1">// запустим приложение Express на порту port</span>
  <span class="nx">app</span><span class="p">.</span><span class="nf">listen</span><span class="p">(</span><span class="nx">port</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="s2">`app listening on </span><span class="p">${</span><span class="nx">port</span><span class="p">}</span><span class="s2">`</span><span class="p">);</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div> <p>Такое приложение будет использовать все доступные CPU. Таким образом, мы увеличим производительность приложения примерно во столько раз, сколько у нас CPU.</p> <h2 id="вывод">Вывод</h2> <p>А нет вывода :) эта статья — просто пример, как Node.js может использовать несколько потоков.</p>]]></content><author><name></name></author><category term="javascript"/><category term="js"/><summary type="html"><![CDATA[Статья о том, как заставить обычное Node.js-приложение использовать все доступные CPU]]></summary></entry></feed>